#########################################################
# 
# geImaging
# 
# Gradient-echo imaging
#
# Copyright (c) Magritek Ltd 2025
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the SpinsolveExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(geImaging, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"geImaging")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("geImaging")
   else
      gExpt->addExperiment(parentPath,"geImaging",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds ["n4"] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["readGrad = 2*pi*nrPnts/(acqTime*1e-3*gamma*FOV*1e-3)",
          "phaseGrad = acqTime*500*readGrad/(echoTime/2-500)",
          "(n1,n2,n3,n4,n5,n6,n7,n8,n9) = geimaging:setImagingPlane(plane,readGrad,phaseGrad,xshim,yshim,zshim,calX,calY,calZ)",
          "d1 = pulseLength1H",
          "d2 = echoTime/2-500",
          "d3 = echoTime/2-d1-4.4-d2-pgo",
          "d4 = echoTime/2-acqTime*500-d1/2+rxLat",
          "n10 = nrPnts",
          "a1 = 90Amplitude1H+20*log10(tipAngle/90)",
          "totPnts = nrPnts",
          "totTime = acqTime"]
   var = ["n4"]
   pp_list = ["n1","n2","n5","n6","a1","p1","d1","n3","n4","d2","n8","d3","n9","d4","n10","n7"]
   pp_name = "geImaging.p"
   phase_list = [0,1,2,3;0,1,2,3]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)

#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)

# Calibration factor (empirical)
   calXFactor = calX/10000 # mT/m with 1 shim units
   calYFactor = calY/10000 # mT/m with 1 shim units
   calZFactor = calZ/10000 # mT/m with 1 shim units (this is a guess - uncalibrated)

# Print out maximum shim
   if(plane[0] == "x")
     maxShim = readGrad/calXFactor
   elseif(plane[0] == "y")
     maxShim = readGrad/calYFactor
   else
     maxShim = readGrad/calZFactor
   endif
   print("\n   Maximum shim = $maxShim$\n")

# Check for too large shim values
   if(maxShim > 32000)
      message("Error","Maximum shim too high - increase FOV or echo-time","error")
      return
   endif

# Do some timing checks
   if(d2 <= 0 | d3 <= 0 | d4 <= 0)
      message("Error","Pulse sequence timing error!\rReduce acquisition time or increase echotime.","error")
      return(0)
   endif

# Initialise output matricies
   Nread  = nrPnts
   Nphase = nrPnts
   idata  = cmatrix(Nread,Nphase) 
   kdata  = cmatrix(Nread,Nphase) 

# Calculate suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000
   fAxis = ([0:1:totPnts-1]-totPnts/2)/totTime

# Get subplots
   (pt1,pt2,im1,im2) = ucsPlot:getPlotReferences()

# Time domain filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTEcho",totPnts)
   else
      flt = matrix(totPnts)+1
   endif

# Do 4 dummy scans
   dummies = 4

# Step through k-space
   for(k = 0 to round(maxPercent*Nphase/100))
  
    # Adjust phase gradient stepping so we move from low k-space to high k-space
     if(k%2 == 0)
        k2 = round(Nphase/2 - k/2)
        pg = k*phaseGrad/Nphase
     else
        k2 = round(Nphase/2 + (k-1)/2)
        pg = -(k-1)*phaseGrad/Nphase
     endif

   # Set the phase gradient
     if(plane[1] == "x")
        gp = (pg + xshim*calXFactor)/calXFactor
     elseif(plane[1] == "y")
        gp = (pg + yshim*calYFactor)/calYFactor
     elseif(plane[1] == "z")
        gp = (pg + zshim*calZFactor)/calZFactor
     endif
    # Check for too large phase gradient
      if(abs(gp) > 32000)
         message("Error","Phase gradient shim too high - increase FOV or echo-time","error")
         return
      endif
      ppList = ucsRun:setPPNumber(ppList,varIndex[0],gp)

   # Accumlated data
     sumData = matrix(totPnts)
   
  # Accumulate scans
      for(scan = -dummies to nrScans-1)

         if(scan == 0)
            sumData = matrix(totPnts)
            dummies = 0
         endif
  
       # Check timing, update the parameters, run the sequence and return the data
         (data,pAcq,status) = ucsRun:runSequence(guipar,ppList,pcList,pcIndex,scan)
   
       # See if the abort button has been pressed
         if(status == "abort")
            return(0)
         endif

       # Filter the data
         data = data .* flt

       # Accumlate the data
         sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)

       # Process data
         (phasedTimeData,spectrum) = ucsRun:transformData(sumData,fAxis,guipar,"echo")
   
       # Plot the data 
         ucsPlot:graphTimeAndFreq(pt1,pt2,tAxis,phasedTimeData,fAxis,spectrum,scan,guipar,
                                  "FID data (Acc:$scan$/$nrScans$)","Magnitude spectrum",
                                  "Time (ms)","Probe output amplitude (\G(m)V)","Frequency kHz","Amplitude")
      
       # Check if complete button pressed
         if(status == "finish")
            scan = scan+1
            exitfor()
         endif
   
      next(scan)

      # Plot the k-space data
      im1->parent->draw("false")    
      im2->parent->draw("false")    
         kdata[~,k2] = sumData
         im1->image(kdata,[-Nread/(2*FOV),Nread/(2*FOV)],[-Nphase/(2*FOV),Nphase/(2*FOV)])
         im1->xlabel("k_($plane[0]$) (mm^(-1))")
         im1->ylabel("k_($plane[1]$) (mm^(-1))")
         im1->title("k-space ($100*k/Nphase,1.1f$%)")
      # 2D FFT with filtering
         idata = fft_local:2d(kdata,Nread,Nphase,"cosinebellsquared","cosinebellsquared","FTEcho","FTEcho","yes")
      # Plot the image data
         im2->image(idata,[0,FOV],[0,FOV])
         im2->xlabel("$plane[0]$ (mm)")
         im2->ylabel("$plane[1]$ (mm)")
         im2->title("Image")
      im1->parent->draw("true")    
      im2->parent->draw("true") 

      if(status == "finish")
         exitfor()
      endif

   next(proj)

# Save the k-space data and image data (the latter to subfolder 'proc')
   ucsFiles:saveImage(im1,:getPlotInfo("im1"),guipar,"noReport")
   ucsFiles:saveImage(im2,:getPlotInfo("im2"),guipar,"simpleReport")

# Save processing parameters
   lst = :getProcPar(nrPnts)

# Return the data
   result = struct()
   result->data = kdata

   return(result)

endproc("execpp")


########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["im1","kSpace.pt2","im2","iData.pt2"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)


#######################################################
# Calculate the amplitude for each of the gradients
# based on the selected plane
#######################################################

procedure(setImagingPlane,plane,readGrad,phaseGrad,xshim,yshim,zshim,calX,calY,calZ)

# Calibration factor (empirical)
  calXFactor = calX/10000 # mT/m with 1 shim units
  calYFactor = calY/10000 # mT/m with 1 shim units
  calZFactor = calZ/10000 # mT/m with 1 shim units (this is a guess - uncalibrated)

   xcal = 1/calXFactor
   ycal = 1/calYFactor
   zcal = 1/calZFactor
   xshim = xshim*calXFactor
   yshim = yshim*calYFactor
   zshim = zshim*calZFactor

#pr readGrad,phaseGrad,xshim,yshim,zshim
   if(plane == "xy")
     n1 = 1 # x
     n3 = 2 # y
     n5 = 0 # z
     n2 = (xshim+readGrad)*xcal
     n4 = (phaseGrad+yshim)*ycal
     n6 = zshim*zcal
     n7 = xshim*xcal
     n8 = yshim*ycal
     n9 = (xshim-readGrad)*xcal
   elseif(plane == "yx")
     n1 = 2 # y
     n3 = 1 # x
     n5 = 0 # z
     n2 = (yshim+readGrad)*ycal
     n4 = (phaseGrad+xshim)*xcal
     n6 = zshim*zcal
     n7 = yshim*ycal
     n8 = xshim*xcal
     n9 = (yshim-readGrad)*ycal
   elseif(plane == "yz")
     n1 = 2 # y
     n3 = 0 # z
     n5 = 1 # x
     n2 = (yshim+readGrad)*ycal
     n4 = (phaseGrad+zshim)*zcal
     n6 = xshim*xcal
     n7 = yshim*ycal
     n8 = zshim*zcal
     n9 = (yshim-readGrad)*ycal
   elseif(plane == "zy")
     n1 = 0 # z
     n3 = 2 # y
     n5 = 1 # x
     n2 = (zshim+readGrad)*zcal
     n4 = (phaseGrad+yshim)*ycal
     n6 = xshim*xcal
     n7 = zshim*zcal
     n8 = yshim*ycal
     n9 = (zshim-readGrad)*zcal
   elseif(plane == "xz")
     n1 = 1 # x
     n3 = 0 # z
     n5 = 2 # y
     n2 = (xshim+readGrad)*xcal
     n4 = (phaseGrad+zshim)*zcal
     n6 = yshim*ycal
     n7 = xshim*xcal
     n8 = zshim*zcal
     n9 = (xshim-readGrad)*xcal
   elseif(plane == "zx")
     n1 = 0 # z
     n3 = 1 # x
     n5 = 2 # y
     n2 = (zshim+readGrad)*zcal
     n4 = (phaseGrad+xshim)*xcal
     n6 = yshim*ycal
     n7 = zshim*zcal
     n8 = xshim*xcal
     n9 = (zshim-readGrad)*zcal
   else
     abort("Invalid plane")
   endif

endproc(n1,n2,n3,n4,n5,n6,n7,n8,n9)

#######################################################
# Make a list of the processing parameters used
#######################################################

procedure(getProcPar,nrPnts)

   4dim = 1
   4dtype = ""
   nrType = "complex"
   3dtype = ""
   2dtype = ""
   1dtype = ""
   experiment = "geImaging"
   matrixIn = "mat2d"
   3dim = 1
   2dim = nrPnts
   1dim = nrPnts
   fileType = "Prospa"
   title = ""
   1dzf = nrPnts
   2dzf = nrPnts
   3dzf = 1
   1dfltr = "sinebellsquared"
   2dfltr = "sinebellsquared"
   3dfltr = "none"
   1dft = "FTEcho"
   2dft = "FTEcho"
   3dft = "none"
   magnitude = "yes"
   digShift = 0

   lst = mkparlist()
   lst = rmfromlist(lst,"nrPnts")
   lst = rmfromlist(lst,"nrArgs")

endproc(lst)


########################################################
# Return expected experiment duration in seconds
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   dummies = 4
   kSpaceSteps = round(maxPercent*nrPnts/100)
   totScans = nrScans*kSpaceSteps + useStartDelay + dummies
   duration = (totScans*repTime)/1000

endproc(duration)