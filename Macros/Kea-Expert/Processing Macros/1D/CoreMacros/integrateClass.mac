###########################################################
# A class to allow regions to be integrated
# in a stacked plot. Works with 1DPlotAnalyser
#
# Author: C Eccles
# Copyright Magritek 2023
#
###########################################################

procedure(init, self)

   self->procedureList = "============================================="
   self->integratePeak         = "integrateClass:integratePeak"
   self->removeIntegral        = "integrateClass:removeIntegral"
   self->clearIntegrals        = "integrateClass:clearIntegrals"
   self->fitToData             = "integrateClass:fitToData"
   self->fitAll                = "integrateClass:fitAll"
   self->readData              = "integrateClass:readData"
   self->drawIntegratedData    = "integrateClass:drawIntegratedData"

   self->variableList = "============================================="
   self->pt1 = null
   self->pt2 = null
   self->regions = null # A array of structure holding the integral region information

   self->colors = [0xE6,0x00,0x49;
                    0x0B,0xB4,0xFF;
                    0x50,0xE9,0x91;
                    0xe6,0xD8,0x00;
                    0x9B,0x19,0xF5;
                    0xFF,0xA3,0x00;
                    0xDC,0x0A,0xB4;
                    0xB3,0xD4,0xFF;
                    0x00,0xBF,0xA0]

   self->symbols = ["opensquare",
                   "square",
                   "opencircle",
                   "circle",
                   "opentriangle",
                   "triangle",
                   "openinvtriangle",
                   "invtriangle",
                   "opendiamond",
                   "diamond"]
   self->nrRegions = 0
   self->xLabel = null

endproc()

# Remove an integral and redraw the plot

procedure(removeIntegral, self)

   n = curwin()->winNr
   pp = getobj(n,1)

   (w,h) = pp->size
   if(w == 1 & h == 2)
      self->pt1 = pp->subplot(1,1)
      self->pt2 = pp->subplot(1,2)
   else
      func1d("multiplot 2*1")
      self->pt1 = pp->subplot(1,1)
      self->pt2 = pp->subplot(1,2)
      self->pt1->rmlines()
      self->pt2->rmlines()
      self->pt2->clear()
   endif

   curplot(self->pt1)
   statusBar->text("Select point inside integral")
   pos1 = getx("value")

# Sometimes the clear button is left highlighted after getx
   clearButton->dehover("true")

   found = 0
   for(k = 0 to self->nrRegions-1)
      if(self->regions->symbols[k] != -1)
         left = self->regions->loc[0,k]
         right = self->regions->loc[1,k]
         if(pos1 >= left & pos1 <= right)
            self->pt1->rmlines(left)
            self->pt1->rmlines(right)
            self->regions->symbols[k] = -1
         else
            found = 1
         endif
      endif
   next(k)
   if(found == 0)
      self->clearIntegrals()
   else
      self->drawIntegratedData()
   endif

   statusBar->text("")

   curplot(self->pt1)

endproc()


#######################################################
# Select a region in pt1 interactively 
# integrate the region and plot the result in pt2
#######################################################

procedure(integratePeak, self)

  # plotcallback("plot1DDblClick","integrateRegion:dblClick")

# Organise the plot if it is new and get plot references
   n = curwin()->winNr

# Allow access to window variable in 1DPlotAnalyser
   guiwinnr(n)
   pp = getobj(n,1)
   (w,h) = pp->size
   if(w == 1 & h == 2)
      self->pt1 = pp->subplot(1,1)
      self->pt2 = pp->subplot(1,2)
   else
      func1d("multiplot 2*1")
      self->pt1 = pp->subplot(1,1)
      self->pt2 = pp->subplot(1,2)
      self->pt1->rmlines()
      self->pt2->rmlines()
      self->pt2->clear()
   endif

# Select the stacked plot
   curplot(self->pt1)
   sz = self->nrRegions
   nrCol = retvar(size(self->colors),2)
   color = self->colors[~,sz % nrCol]
   symbol = sz % size(self->symbols)

# Choose the integral region
   statusBar->text("Select points either side of peak")
   pos1 = getx("value")
   self->pt1->addline(pos1,-inf,pos1,inf,color,2,"solid")
   statusBar->text("Select other side of peak")
   pos2 = getx("value")
   self->pt1->addline(pos2,-inf,pos2,inf,color,2,"solid")
   if(pos1 > pos2)
      swapvar(pos1,pos2)
   endif
   avgPPM = (pos1+pos2)/2
   getobj(n,2)->text("")

# Sometimes these buttons are left highlighted so redraw
   rmButton->dehover("true")
   clearButton->dehover("true")

# Save this region
   if(self->regions == null)
     # Intialize region structure
      self->regions = struct()
      self->regions->loc = matrix(2,1)
      self->regions->loc[0,0] = pos1
      self->regions->loc[1,0] = pos2
      self->regions->dataZ = null
      self->regions->dataInt = null
      self->regions->fitInt = null
      self->regions->colors = color
      self->regions->symbols = [symbol]
   else
    # Add the new region selected
      pos = matrix(2)
      pos[0] = pos1
      pos[1] = pos2
      self->regions->loc = join(self->regions->loc, pos, "horiz")
      self->regions->colors = join(self->regions->colors, color, "horiz")
      self->regions->symbols = join(self->regions->symbols, [symbol])
   endif
   self->nrRegions = self->nrRegions + 1

# Get the z axis data from the trace names
   tracelst = self->pt1->tracelist()
   sz = size(tracelst)
   z = matrix(sz)
   err = 0
   for(k = 0 to sz-1)
      txt = self->pt1->trace(k)->name
      try
         (protocol,comment) = scanstr(txt,"%1(%2)")
      catch
         comment = txt
      endtry
      if(isfloat(comment))
         z[k] = eval(comment)
      else
         z[k] = k
         err = 1
      endif
   next(k)
   if(err)
      print("Data abscissa not recorded - using index\n")
   endif

# Integrate the stacked plot data 
   ints = matrix(sz)
   for(k = 0 to sz-1)
      (x,y) = self->pt1->trace(k)->getdata
      ints[k] = integvector(x,real(y),pos1,pos2)
   next(k)

# Copy the z and integral data pairs into the dataInfo list 
   dataInfo = list(sz+1)
   dataZArray = matrix(sz)
   dataIntArray = matrix(sz)
   dataInfo[0] = "x|y"
   for(k = 1 to sz)
      dataInfo[k] = "$z[k-1]$|$ints[k-1]$"  
   next(k)
   dataList->nrcolumns(2)
   dataList->list(dataInfo)
   dataList->color([0,0,128,0])
   dataList->colwidth([0.3,0.7])
   rawDataGB->label("Raw Data ($pos1,1.1f$ to $pos2,1.1f$ ppm)")

# Record the z and integral data into the regions structure
   self->regions->dataZ = z
   self->regions->dataInt = join(self->regions->dataInt,ints,"horiz")
   self->regions->fitInt = join(self->regions->fitInt,matrix(sz)+nan,"horiz")

# Plot the integral data
   self->drawIntegratedData()

# Fit if requested
   if(autoFit->text == "true")
      if(fitList->text == null)
         message("Error","Please select a fit function\rand try again.","error")
         return
      endif
      idx = retvar(size(self->regions->dataInt),2)-1
      self->fitToData(idx)
   endif

# Leave the integral data selected
   curplot(self->pt2)

endproc()

#######################################################
# Update the integrated data in plot pt2
#######################################################

procedure(drawIntegratedData, self)

# Update the color and symbol for each region
   sz = self->nrRegions

   curplot(self->pt2)
   try
      trcNr = curtrace()->id # The current trace nr
   catch
      trcNr = -1
   endtry
   x = self->regions->dataZ

   self->pt2->draw("false")
   self->pt2->hold("off")

   for(k = 0 to self->nrRegions-1)

      if(self->regions->symbols[k] >= 0)
         symbol = self->symbols[self->regions->symbols[k]]

         y = self->regions->dataInt[~,k]
         fit = self->regions->fitInt[~,k]
         color = self->regions->colors[~,k]
   
      # Draw all raw and fitted data
         n = self->pt2->plot(x,y,"symbolshape",symbol,
                             "symbolcolor",color,
                             "tracecolor",color,
                             "tracetype","none")
   
         self->pt2->hold("on")
   
         self->pt2->trace(n)->name("$k$")
         
         if(fit[0] != nan)
            m = self->pt2->plot(x,fit,"symbolshape","none",
                                "symbolcolor",color,
                                "tracecolor",color,
                                "tracetype","lines")
   
            self->pt2->trace(m)->name("$k$")
   
         endif
      endif

   next(k)

   self->pt2->grid->xgrid("on")
   self->pt2->grid->ygrid("on")
   self->pt2->grid->finexgrid("on")
   self->pt2->grid->fineygrid("on")
   self->pt2->title("Integrated data")
   self->pt2->ylabel("Integral")
   if(self->xLabel != null)
      self->pt2->xlabel(self->xLabel)
   else
      self->pt2->xlabel(self->pt1->ylabel->text)
   endif
   self->pt2->hold("off")
   self->pt2->draw("true")
   if(trcNr != -1)
      curtrace(trcNr) # Restore current trace
   endif
   curplot(self->pt2)

endproc()

#######################################################
# Clear all the integral data
#######################################################
procedure(clearIntegrals, self)

   self->nrRegions = 0
   self->regions->dataInt = null
   self->regions->fitInt = null
   self->regions->loc = null
   self->regions->symbols = null
   self->regions->colors = null
   self->pt1->rmlines()
   self->pt2->clear()

endproc()

#######################################################
# Try and fit the currently selected function to 
# all integrate data curves
#######################################################
procedure(fitAll, self)

   if(fitList->text() == null)
      message("Error","Please select a fit function\rand try again.","error")
      return
   endif

   self->pt2->parent->draw("false")
   print("\n\n ------------------ Fit results ------------------ \n\n")
   for(k = 0 to self->nrRegions-1)
      if(self->regions->symbols[k] != -1)
         result = self->fitToData(k)
         if(k == 0)
            print("   Fit function '$result->fitName$': $result->func$ \n\n")
         endif
         ppm = self->regions->loc[~,k]
         print("   ($ppm[0],1.2f$ to $ppm[1],1.2f$) ppm\n")
         for(k = 1 to result->n)
            num = eval("result->p$k$")
            err = eval("result->p$k$err")
            print("      p$k$ = $errorstr(num,err,2)$   ($abs(100*err/num),1.2g$%)\n")
         next(k)
         print("\n")
      endif
   next(k)
   print(" ------------------------------------------------- \n\n")

   self->pt2->parent->draw("true")

endproc()

#######################################################
# Fit the selected fit function to the currently 
# selected integrated data or by idx if specified
#######################################################
procedure(fitToData, self, idx=null)
 
   x = self->regions->dataZ
   if(idx == null)
      idx = eval(curtrace()->name)
   endif
   y = self->regions->dataInt[~,idx]
   sz = size(x)
   txt = fitList->text()

# Perform the requested fit
   p1 = 0; p2 = 0; p3 = 0;
   p1err = 0; p2err = 0; p3err = 0;
   chisq = 0
   n = 0

   self->xLabel = null

   try
      (name,func) = scanstr(txt,"%1|%2")
      if(name == "Linear")
         init = [(y[-1]-y[0])/(x[-1]-x[0]),y[0]]
         (p1,p2,p1err,p2err,chisq) = nlinfit(x,y,":linFunc",init,0,"no",50)
         f = p1*x+p2
         n = 2
      elseif(name == "Exponential")
         idx2 = findindex2(y,0,"right",y[0]*0.37)
         init = [y[0],idx2]
         (p1,p2,p1err,p2err,chisq) = nlinfit(x,y,":expFunc",init,0,"no",50)
         f = p1*exp(-x/p2)
         n = 2
      elseif(name == "Sine")
         init = [min(y),1/180,0]
         (p1,p2,p3,p1err,p2err,p3err,chisq) = nlinfit(x,y,":sineFunc",init,0,"no",50)
         f = p1*sin(x*p2+p3)
         n = 3
      elseif(name == "Cosine")
         init = [max(y),1/180,0]
         (p1,p2,p3,p1err,p2err,p3err,chisq) = nlinfit(x,y,":cosineFunc",init,0,"no",50)
         f = p1*cos(x*p2+p3)
         n = 3
      elseif(name == "T1IR")
         idx2 = findindex2(y,0,"right",0)
         if(idx2 >= 0 & idx2 < sz)
            init = [(y[-1]-y[0])/2,x[idx2]/0.693]
            (p1,p2,p1err,p2err,chisq) = nlinfit(x,y,":t1IRFunc",init,0,"no",50)
            f = p1*(1-2*exp(-x/p2))
            n = 2
         else
            pr ("Can't find zero crossing - invalid model for fit\n")
            return(null)
         endif
      elseif(name == "PGSE")

        # Need to get this information from main interface
         proc = gData->curExpt->protocol+":getExptInfo"
         s = proc()
         smdel = s->smDelta
         lgdel = s->bgDelta
         gradAmp = s->gradAmp
         nrSteps = s->nSteps
         gammaX = s->gammaX
         x = s->xAxis
         self->xLabel = "Gradient (T/m)"
         midIdx = round(sz/2) 
         Dpred = -loge(y[midIdx]/y[0])/(gammaX^2*x[midIdx]*smdel^2*(lgdel-smdel/3))
         init = [max(y),Dpred*1e9]
         xMod = (smdel*gammaX*x)^2*(lgdel-smdel/3.0)/1e9
         (p1,p2,p1err,p2err,chisq) = nlinfit(xMod,y,":PGSEFunc",init,0,"no",50)
         f = :PGSEFunc(xMod,p1,p2)
         n = 2
      endif
   catch
      pr lasterror()
      pr("\n   *** Fit failed - check data or initial conditions ***\n")
   endtry

   self->regions->fitInt[~,idx] = f

# Plot the data
   self->drawIntegratedData()

# Update the data list
   dataInfo = list(sz+1)
   dataZArray = matrix(sz)
   dataIntArray = matrix(sz)
   dataInfo[0] = "x|y"
   for(k = 1 to sz)
      dataInfo[k] = "$x[k-1]$|$y[k-1]$"  
   next(k)
   dataList->nrcolumns(2)
   dataList->list(dataInfo)
   dataList->color([0,0,128,0])
   dataList->colwidth([0.3,0.7])
   pos1 = self->regions->loc[0,idx]
   pos2 = self->regions->loc[1,idx]
   rawDataGB->label("Raw Data ($pos1,1.1f$ to $pos2,1.1f$ ppm)")
   
   getobj(0,20)->label("Raw data: $self->regions->loc[0,idx],1.2f$ to $self->regions->loc[1,idx],1.2f$ ppm")

   result = struct(n = n, func=func, fitName=name, p1 = p1, p2 = p2, p3 = p3,
                   p1err = p1err, p2err = p2err, p3err = p3err, chisq = chisq)  

endproc(result)



procedure(readData, self)

   lst = dataList->list
   sz = size(lst)
   x = matrix(sz-1)
   y = matrix(sz-1)
   for(k = 1 to sz-1)
      (xv,yv) = scanstr(lst[k],"%1|%2")
      try
         x[k-1] = eval(xv)
      catch
         x[k-1] = k-1
      endtry
      y[k-1] = eval(yv)
   next(k)

endproc(x,y)

# Double click callback - update raw data with selected trace
procedure(dblClick, x, y)

# Make sure window variables are available for this callback
   curwin(curwin()->winnr)

# Update the raw data list
   trc = wvInt->pt2->curtrace()
   (x,y) = trc->getdata()
   sz = size(x)
   dataInfo = list(sz+1)
   dataInfo[0] = "x|y"
   for(k = 1 to sz)
     dataInfo[k] = "$x[k-1]$|$y[k-1]$"
   next(k)
   dataList->nrcolumns(2)
   dataList->list(dataInfo)
   dataList->color([0,0,128,0])
   dataList->colwidth([0.3,0.7])

endproc()

#######################################################
# Fit functions and partial derivatives for the NL fit
#######################################################
procedure(linFunc, x, p1, p2)

   y = p1*x + p2
   dydp1 = x
   dydp2 = 1

endproc(y,dydp1,dydp2)
      

procedure(expFunc, x, p1, p2)

   e = exp(-x/p2)
   y = p1*e
   dydp1 = e
   dydp2 = p1*x*e/(p2^2) 

endproc(y,dydp1,dydp2)

procedure(sineFunc, x, p1, p2, p3)

   e = sin(x*p2+p3)
   y = p1*e
   dydp1 = e
   dydp2 = p1*x*cos(x*p2+p3) 
   dydp3 = p1*cos(x*p2+p3) 

endproc(y,dydp1,dydp2,dydp3)

procedure(cosineFunc, x, p1, p2, p3)

   e = cos(x*p2+p3)
   y = p1*e
   dydp1 = e
   dydp2 = -p1*x*sin(x*p2+p3) 
   dydp3 = -p1*sin(x*p2+p3) 

endproc(y,dydp1,dydp2,dydp3)

procedure(t1IRFunc, x, p1, p2)

   e = exp(-x/p2)
   f = (1-2*e)
   y = p1*f
   dydp1 = f
   dydp2 = -p1*x*2*e/(p2^2)

endproc(y,dydp1,dydp2)

procedure(PGSEFunc, x, p1, p2)

   e = exp(-x*p2)
   y = p1*e
   dydp1 = e
   if(vartype(x) == "float")
      dydp2 = -x*p1*e
   else
      dydp2 = -p1*x.*e
   endif

endproc(y,dydp1,dydp2)

