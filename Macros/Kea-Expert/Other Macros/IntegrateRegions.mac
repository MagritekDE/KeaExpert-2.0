###############################################
# Select a region for integration
# Either called from the current experiment
# or from a postprocessing button.
# The information needed is stored in the
# global variable gShared.
###############################################

procedure(AddIntegral, function="None", specPlot="pt3", intPlot="pt4")

# Allow editing
   if(EditIfShiftPressed(getmacropath(),getmacroname()))
      return
   endif

# Get plot regions
   pt1 = gPlot->getPlotObject(specPlot)
   pt2 = gPlot->getPlotObject(intPlot)

# Update the shared data if not present
   if(isvar("gShared") == 0)
      :createSharedInfo(pt1,pt2)
   endif

# If no data return
   if(gShared->dataPresent == 0)
      print("\n   No Stacked plot data present\n")
      return
   endif
   
# Get the color for the integral region
   col = :getNextColor()

# Select the integral regions
   gView->statusCtrl->text("Select one side of peak")
   pos1 = getx("value")

   pt1->addline(pos1,-inf,pos1,inf,col,2,"solid")
   gView->statusCtrl->text("Select other side of peak")
   pos2 = getx("value")
   pt1->addline(pos2,-inf,pos2,inf,col,2,"solid")
   if(pos1 > pos2)
      swapvar(pos1,pos2)
   endif
   avgPPM = (pos1+pos2)/2
   gView->statusCtrl->text("")

# Add the integral region to a shared array
   ir = gShared->integralRegions
   if(ir == null)
      ir = join([pos1,pos2,0],col)
   else
      ir = join(ir,join([pos1,pos2,0],col),"horiz")
   endif
   gShared->integralRegions = ir

# Update the display with the new integral
   :drawIntegrals(pt1,pt2,function,avgPPM)

# Note that this color has been used
   :setColorUsed(col,1)

# Update the plot file info
   protocol = gData->curExpt->protocol
   proc = "$protocol$:getPlotInfo"
   fileName = proc(intPlot)
   pt2->filename(fileName)
   pt2->filepath(gData->curExpt->dataPath)

endproc()

###############################################
# Get the next free color otherwise start again
###############################################

procedure(getNextColor)

# Search for the first free color
   (w,h) = size(gShared->colorScale)

   col = null
   for(k = 0 to h-1)
      if(gShared->colorsUsed[k] == 0)
         col = gShared->colorScale[~,k]
         exitfor
      endif
   next(k)

# All colors have been used so start again
   if(col == null)
      gShared->colorsUsed = matrix(h)
      col = gShared->colorScale[~,0]
   endif

endproc(col)

###############################################
# Set or clear an entry in the colorsUsed array
# which matched color 'col'
###############################################

procedure(setColorUsed, col, status)

   (w,h) = size(gShared->colorScale)
   for(k = 0 to h-1)
      if(col == gShared->colorScale[~,k])
         gShared->colorsUsed[k] = status
         exitfor
      endif
   next(k)

endproc()


###############################################
# Get a color table for coloring integrals
###############################################

procedure(getColorTable)

#   colors = [255,0,0;
#             255,128,0;
#             204,204,0;
#             153,255,51;
#             51,255,153;
#             51,255,255;
#             51,153,255;
#             51,51,255;
#             153,51,255;
#             255,51,255;
#             255,51,153;
#             160,160,160]

  colors = [204,0,0;
             255,128,0;
           #  204,102,0;
             204,204,0;
             0,204,0;
             0,204,204;
             0,102,204;
             0,0,204;
             102,0,204;
             204,0,204;
             255,0,127;
             96,96,96]

endproc(colors)

###############################################
# Create the shared integral information if 
# not present
###############################################

procedure(createSharedInfo, pt1, pt2)

   assign("gShared",struct(),"global")

# Get a list of the stackplot traces
   ids = pt1->tracelist()
   nrExpts = size(ids)

# Get y axis
   mapping = pt1->axes->ymapping
   mn = pt1->axes->minaxisvalue
   mx = pt1->axes->maxaxisvalue
   if(mapping == "lin")
      gShared->dArray = linspace(mn,mx,nrExpts)
   else
      gShared->dArray = logspace(mn,mx,nrExpts)
   endif

# Reorganise the stacked plot into a 2D spectrum
   if(nrExpts > 0)
      (fAxis,spectrum) = pt1->trace(ids[0])->getdata()
      gShared->fAxis = fAxis
      gShared->spec2d  = cmatrix(size(spectrum),nrExpts)
      gShared->spec2d[~,0] = spectrum
      for(p = 1 to nrExpts-1)
         (fAxis,gShared->spec2d[~,p]) = pt1->trace(ids[p])->getdata()
      next(p)
      gShared->nrSteps = nrExpts
      gShared->integralStep = nrExpts-1

   # Make the colors
      gShared->colorScale = :getColorTable()
      (w,h) = size(gShared->colorScale)
      gShared->colorsUsed  = matrix(h)

   # Get the integral regions
      lines = pt1->getlines()
      if(lines != null)
         nrLines = size(lines)
         gShared->integralRegions = matrix(5,nrLines/2)

         for(k = 0 to  nrLines-1 step 2)
            idx = k/2
            first = lines[k]->x0
            second = lines[k+1]->x0
            if(first > second)
               swapvar(first,second)
            endif
            gShared->integralRegions[0,idx] = first
            gShared->integralRegions[1,idx] = second
            gShared->integralRegions[[2:4],idx] = lines[k]->color
            :setColorUsed(lines[k]->color,1)
         next(k)
      else
         gShared->integralRegions = null
      endif

   # Get the integral values
      ids = pt2->tracelist()
      nrIntegrals = size(ids)/2
      gShared->integralValues = null
      for(k = 0 to size(ids)-1)
         name = pt2->trace(ids[k])->name()
         if(name != "peakIntegrals")
            gShared->integralValues = gShared->integralValues + ["$name$"]
         endif
      next(k)        
  
   # Indicate that data is present
      gShared->dataPresent = 1

   else

      gShared->dataPresent = 0

   endif

   gShared->drawing = 0


endproc()


##########################################
# Initialise the shared data from the 
# experiment macro
##########################################

procedure(initSharedData,fAxis,nrPnts,nrSteps,dArray,bulkRegion=null)

   assign("gShared",struct(),"global")
   gShared->colorScale      = :getColorTable()
   (w,h) = size(gShared->colorScale)
   gShared->colorsUsed      = matrix(h)
   col = gShared->colorScale[~,0]
   if(bulkRegion == null)
      gShared->integralRegions = null
   else
      gShared->integralRegions = join(join(bulkRegion,[1]),col)
   endif
   gShared->integralValues  = null
   gShared->integralStep    = -1
   gShared->fAxis           = fAxis
   gShared->nrSteps         = nrSteps
   gShared->dArray          = dArray/1000
   gShared->spec2d          = cmatrix(nrPnts,nrSteps)
   gShared->drawing         = 0
   gShared->dataPresent     = 0

endproc()


##########################################
# Remove an integral from the list 
# and update the display
##########################################

procedure(RemoveIntegral, function="None", specPlot="pt3", intPlot="pt4")

# Allow editing
   if(EditIfShiftPressed(getmacropath(),getmacroname()))
      return
   endif

# Get plot regions
   pt1 = gPlot->getPlotObject(specPlot)
   pt2 = gPlot->getPlotObject(intPlot)

   if(isvar("gShared") == 0)
      :createSharedInfo(pt1,pt2)
   endif

   gView->statusCtrl->text("Select point inside integral")
   pos1 = getx("value")

   regions = gShared->integralRegions
   if(regions == null)
      return   
   endif

   (w,h) = size(regions)

   pt1 = gPlot->getPlotObject(specPlot)

   cnt = 0
   newRegions = null
   for(k = 0 to h-1)
      region = regions[~,k]
      if(pos1 < region[0] | pos1 > region[1])
         if(cnt == 0)
            newRegions = region
         else
            newRegions = join(newRegions, region, "horiz")
         endif
         cnt = cnt + 1
      elseif(pos1 >= region[0] & pos1 <= region[1])
         pt1->rmlines(region[0])
         pt1->rmlines(region[1])
         :setColorUsed(region[2:4],0)
      endif
   next(k)
     
   gShared->integralRegions = newRegions

# Update the display
   pt2 = gView->g4->subplot(1,1)
   :drawIntegrals(pt1,pt2,function,pos1)

endproc()

##########################################
# Remove all the integrals 
# and update the display
##########################################

procedure(ClearIntegrals, function="None", specPlot="pt3", intPlot="pt4")

# Allow editing
   if(EditIfShiftPressed(getmacropath(),getmacroname()))
      return
   endif

# Get plot regions
   pt1 = gPlot->getPlotObject(specPlot)
   pt2 = gPlot->getPlotObject(intPlot)

   if(isvar("gShared") == 0)
      :createSharedInfo(pt1,pt2)
   endif

   gShared->integralRegions = null

# Update the display
   pt1->rmlines()
   pt2->rmlines()
   (w,h) = size(gShared->colorScale)
   gShared->colorsUsed = matrix(h)
   :drawIntegrals(pt1,pt2,function)

endproc()


##########################################
# Remove all the integrals 
# and update the display
##########################################

procedure(PrintIntegrals, function="None", specPlot="pt3", intPlot="pt4")

# Allow editing
   if(EditIfShiftPressed(getmacropath(),getmacroname()))
      return
   endif

# Get plot regions
   pt1 = gPlot->getPlotObject(specPlot)
   pt2 = gPlot->getPlotObject(intPlot)

   if(isvar("gShared") == 0)
      :createSharedInfo(pt1,pt2)
   endif

   sz = size(gShared->integralValues)
   if(sz > 0)
      if(function == "T2")
         print("\n\n   Peak (ppm)      T2 (s)\n")
      elseif(function == "T1IR")
         print("\n\n   Peak (ppm)      T1 (s)\n")
      endif
      print("  -----------------------------\n")

      if(function != "None")
         for(k = 0 to sz-1)
           txt = gShared->integralValues[k]
            entry = parse(txt,",")
            if(entry[1] != "raw")
               if(entry[0] != "bulk")
                  position = eval(entry[0])
               else
                  position = "bulk"
               endif
               value = eval(entry[1])
               if(value != "raw")
                  print("     $position,5.2f$         $value,5.2f$\n")
               endif 
            endif
         next(k)
         print("\n")
      endif

   endif

endproc()


#######################################################################
# Draw the integrals and fit to a T1-IR curve. Shared data structure
# allows real time selection of integrals from a post processing
# button. This procedure can also be called from an experiment
#######################################################################

procedure(drawIntegrals, pt1,pt2, function, avgPPM=0)
 
# Only one macro can call this procedure at a time
   if(gShared->drawing)
      return
   endif

   gShared->drawing = 1

# Make local copies of the shared data
   gShared->dataPresent = 1
   spec2d = gShared->spec2d
   fAxis = gShared->fAxis
   d = gShared->integralStep
   nrSteps = gShared->nrSteps
   dArray = gShared->dArray
   ir = gShared->integralRegions

# Clear all integral results
   pt2->rmtext()
   pt2->rmlines()
   pt2->clear()

# Return if no integral data
   if(ir == null)
      gShared->drawing = 0
      return
   endif

# Integrate the selected regions
   echoDelay  = matrix(nrSteps)
   echoInt    = matrix(nrSteps)

   shiftMat = [0,0;0,0]

   pt2->draw("false")

  (w,h) = size(ir)

   if(function == "T2")
      pt2->addtext([-110,10],"  Peak  T2(s)",shiftMat,"Courier New",9,0,"regular",[0,0,0],"pp")
      pt2->addline(-103,26,-15,26,[128,128,128],1,"solid",1)
      pt2->addline(-55,12,-55,12+12+15*h*1.1,[128,128,128],1,"solid",1)
   elseif(function == "T1IR")
      pt2->addtext([5,10],"  Peak  T1(s)",shiftMat,"Courier New",9,0,"regular",[0,0,0],"pp")
      pt2->addline(12,26,100,26,[128,128,128],1,"solid",1)
      pt2->addline(60,12,60,12+12+15*h*1.1,[128,128,128],1,"solid",1)
   endif
   pt2->axes->xdirection("forward")

   for(k = 0 to h-1)

      leftPPM  = ir[0,k]
      rightPPM = ir[1,k]
      type = ir[2,k]
      col = ir[3:5,k]
      for(q = 0 to d)
         echoInt[q]   = 2*integvector(fAxis,real(spec2d[~,q]),leftPPM,rightPPM)
         echoDelay[q] = dArray[q]  
      next(q)   

      if(k == 0)
         shape = "opensquare"
      else
         shape = "opencircle" 
      endif    

    # Plot the integrals and fit vs delay 
      if(type == 0)
         avgPPM = (leftPPM+rightPPM)/2
      else
         avgPPM = "  bulk"
      endif
      fitStr = :plotIntegralsCore(pt1,pt2,k,echoDelay[0:d],echoInt[0:d],col,shape,function,avgPPM)

   next(k)

   pt2->hold("off")
   pt2->draw("true")

# Get the integral values
   ids = pt2->tracelist()
   nrIntegrals = size(ids)/2
   gShared->integralValues = null
   for(k = 0 to size(ids)-1)
      name = pt2->trace(ids[k])->name()
      if(name != "peakIntegrals")
         gShared->integralValues = gShared->integralValues + ["$name$"]
      endif
   next(k) 

   gShared->drawing = 0

endproc()


#######################################################################
# Core procedure for plotting the integral data and fit
#######################################################################

procedure(plotIntegralsCore,pt1,pt2,intNr,echoDelay,peakIntegrals,col,shape,function,integralPPM)

   traceType = "none"

# Fit the data
   try
      if(function == "T1IR")
         (fit,Ea,Ta,errEa,errTa) = t1fit(echoDelay,peakIntegrals,"ir")
         fitStr = "$integralPPM,6.2f$ $Ta,6.3f$"     
      elseif(function == "T1SR")
         (fit,Ea,Ta,errEa,errTa) = t1fit(echoDelay,peakIntegrals,"vd")
         fitStr = "$integralPPM,6.2f$ $Ta,6.3f$"
      elseif(function == "T2")
         (fit,Ea,Ta,errEa,errTa) = t2fit(echoDelay,peakIntegrals)
         fitStr = "$integralPPM,6.2f$ $Ta,6.3f$"
      else
         fit = null
         fitStr = ""
         traceType = "lines"
      endif
   catch
      fit = null
      fitStr = ""
      traceType = "lines"
   endtry

# Add the fitted curve
   shiftMat = [0,0;0,(intNr+1)*1.1]

   if(function != "None" & fitStr != "")

      if(function == "T2")
         pt2->addtext([-110,10],fitStr,shiftMat,"Courier New",9,0,"regular",col,"pp")
      else
         pt2->addtext([3,10],fitStr,shiftMat,"Courier New",9,0,"regular",col,"pp")
      endif
      tc = pt2->plot(echoDelay,fit,"color", col)
      pt2->trace(tc)->name("$integralPPM,0.2f$,$Ta,0.2f$")

   endif

# Plot the raw data
   pt2->hold("on")
   tc = pt2->plot(echoDelay,peakIntegrals,
             "tracetype", traceType, "symbolshape", "opensquare",
             "symbolcolor",col,
             "tracecolor",col)
   pt2->trace(tc)->name("$integralPPM,0.2f$,raw")

   varLabel = pt1->ylabel->text
   pt2->title("Peak integrals")
   pt2->xlabel(varLabel)
   pt2->ylabel("Integral")
   pt2->axes->xmapping("linear")

endproc(fitStr)


##########################################
# Remove an integral from the list 
# and update the display
##########################################

procedure(TogglePlotsDisplayed)

# Allow editing
   if(EditIfShiftPressed(getmacropath(),getmacroname()))
      return
   endif

   if(wvExpStatus == "running")
      (w,h) = size(gPlot->curPlotLayout)
      if(w == [2,2])
         layout = ["pt3";"pt4"]
      elseif(w == [2,1])
         layout = ["pt3","pt4"]
      else
         layout = ["pt1","pt2";"pt3","pt4"]
      endif
      gPlot->layoutPlots(layout,"keep")
      gPlot->showPlots(layout)
   else
      if(vartype(gPlot->curPlotLayout) == "list")
         layout = ["pt3";"pt4"]
      else
         layout = ["pt3","pt4"]
      endif
      gPlot->layoutPlots(layout,"keep")
      gPlot->showPlots(layout)
   endif

endproc()


##########################################
# Swap between a log and linear display
##########################################

procedure(LogLinT2, intPlot="pt4")

   pt2 = gPlot->getPlotObject(intPlot)
   ids = pt2->tracelist()
   nrExpts = size(ids)

   if(nrExpts > 0)

   # Extract the existing data
      (x,y) = pt2->trace(ids[0])->getdata()
      sz = size(x)
      intData = matrix(sz,nrExpts)
      names = null
      for(k = 0 to size(ids)-1)
         name = pt2->trace(ids[k])->name()
         names = names + ["$name$"]
         (x,intData[~,k]) = pt2->trace(ids[k])->getdata()
      next(k) 

    # Replot it in linear mode
      pt2->clear()
      pt2->hold("on")
      for(k = 0 to nrExpts-1)
         try
            (ppm,E0,T2) = parse(names[k],",")
             E0 = eval(E0)
             T2 = eval(T2)
             y0 = intData[~,k]
             y1 = loge(-y0/E0)
             plot(x,y1)
         catch
             y0 = intData[~,k]
             y1 = loge(0.5*(1-y0/E0))
             plot(x,y1,"symbolshape","opensquare","tracetype", "none")             
         endtry
      next(k)
      pt2->hold("off")

   endif


endproc()

