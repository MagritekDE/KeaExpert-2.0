###################################################################################
# Acquire data into the TRex SRAM memory. 
#
#    acquire(mode, nrPnts, [duration])
#
#    mode     : Overwrite (or start)/append
#    nrPnts   : Number of complex points to collect (1 ... 128k)
#    duration : Optional duration in us when using append mode.  
#               Must be longer than the acquisition time.
#
#    Use subprocedure getAcqTime to return estimate of acquisition time
#
###################################################################################

procedure(acquire, mode, nrPnts=128, duration=0)

   if(wvFX3Info->mode == "run")

      dwellTime = wvFX3Info->dwellTime
      lineCnt = wvFX3Info->lineCnt
      adrs = 0
      trueAcqTime = round(100.0/100.0*:getAcqTime(dwellTime, nrPnts, (wvFX3Info->flatFilter=="yes"))*100.0)

      if(wvFX3Info->board == "TRex") # TRex board
   
         if(mode == "start" | mode == "overwrite")
            ps = [20d,             0x041A3, nrPnts, # Number of points to collect
                  20d,             0x04081, 0x3,    # DDC and output enable
                  20d,             0x06081, 0x1,    # Reset FIFO
                  20d,             0x06081, 0x6,    # FIFO select FIR/CIC as input
                  20d,             0x04082, 0x00,    # Overwrite mode
                  20d,             0x00000, wvFX3Info->currentTTL | 0x10,  # Reset CIC
                  trueAcqTime+20d, 0x00000, wvFX3Info->currentTTL | 0x01,  # ADC start
                  180d,            0x00000, wvFX3Info->currentTTL]         # ADC stop

         elseif(mode == "append") # No fifo reset and a duration
            duration = round(duration/0.01)
            ps = [20d,             0x041A3, nrPnts,  # Number of points to collect
                  20d,             0x04081, 0x3,     # DDC and output enable
                  20d,             0x06081, 0x6,     # FIFO select FIR/CIC as input
                  20d,             0x04082, 0x02,    # Append mode
                  20d,             0x04083, nrPnts,  # Number of points per block
                  20d,             0x00000, wvFX3Info->currentTTL | 0x10, # Reset CIC
                  trueAcqTime+20d, 0x00000, wvFX3Info->currentTTL | 0x01] # ADC start

            if(duration >= (140 + trueAcqTime))
               ps = join(ps,[duration-trueAcqTime-140d, 0, wvFX3Info->currentTTL]) # ADC stop
            else
               ps = join(ps,[80d, 0, wvFX3Info->currentTTL]) # ADC stop
            endif

         elseif(mode == "integrate") # No fifo reset and a duration sum all data points
            duration = round(duration/0.01)
            ps = [20d,             0x041A3, nrPnts,  # Number of points to collect
                  20d,             0x04081, 0x3,     # DDC and output enable
                  20d,             0x06081, 0x6,     # FIFO select FIR/CIC as input
                  20d,             0x04082, 0x01,    # Sum mode 
                  20d,             0x04083, nrPnts,  # Number of points to sum
                  20d,             0x00000, wvFX3Info->currentTTL | 0x10, # Reset CIC
                  trueAcqTime+20d, 0x00000, wvFX3Info->currentTTL | 0x01] # ADC start

            if(duration >= (140 + trueAcqTime))
               ps = join(ps,[duration-trueAcqTime-140d, 0, wvFX3Info->currentTTL]) # ADC stop
            else
               ps = join(ps,[80d, 0, wvFX3Info->currentTTL]) # ADC stop
            endif

         elseif(mode == "sum") # No fifo reset and a duration sum points to a vector
            duration = round(duration/0.01)
            ps = [20d,             0x041A3, nrPnts,  # Number of points to collect
                  20d,             0x04081, 0x3,     # DDC and output enable
                  20d,             0x06081, 0x6,     # FIFO select FIR/CIC as input
                  20d,             0x04082, 0x03,    # Sum mode 
                  20d,             0x04083, nrPnts,  # Number of points to sum
                  20d,             0x00000, wvFX3Info->currentTTL | 0x10, # Reset CIC
                  trueAcqTime+20d, 0x00000, wvFX3Info->currentTTL | 0x01] # ADC start

            if(duration >= (140 + trueAcqTime))
               ps = join(ps,[duration-trueAcqTime-140d, 0, wvFX3Info->currentTTL]) # ADC stop
            else
               ps = join(ps,[80d, 0, wvFX3Info->currentTTL]) # ADC stop
            endif

         else
            print("Error in acquire\n")
         endif

      endif
   
      wvFX3Info->nrPnts = nrPnts

      updatePSArray(ps)

   elseif(wvFX3Info->mode == "time")

      args = getargnames()
      cnt = gSeq->psInfo->loopCnt
      if(nrArgs == 2)
         dwellTime = gSeq->psInfo->guipar->dwellTime
         gSeq->psInfo->durationNStk[cnt] = gSeq->psInfo->durationNStk[cnt] + nrPnts*dwellTime
         gSeq->psInfo->command = gSeq->psInfo->command + ["acquire,$mode$,$nrPnts$,$dwellTime$,$args[0]$"]
      else
         gSeq->psInfo->durationNStk[cnt] = gSeq->psInfo->durationNStk[cnt] + duration
         gSeq->psInfo->command = gSeq->psInfo->command + ["acquire,$mode$,$nrPnts$,$duration$,$args[0]$,$args[1]$"]
      endif

   elseif(wvFX3Info->mode == "compile")

      if(duration == 0)
         addPSParameters(nrPnts)
      else
         addPSParameters(nrPnts, duration)
      endif

   endif

endproc()


####################################################
# Return the approximate acquisition time in us
#
#    getAcqTime(dwellTIme, nrPnts, useFIRFilter)
#
#    dwellTime : sampling interval in us
#    nrPnts : number of points to collect.
#    useFIRFilter : 1/0 (flat filter)
#
####################################################

procedure(getAcqTime, dwellTime, nrPnts, useFIRFilter)

   ignorePnts = 6
   
   MaxSpeed = 65
   nrTaps = 20
   if(useFIRFilter)
      CIC_Scale = 3
   else
      CIC_Scale = 11
   endif
   
   FIRScale = 2
   
   if(2 * nrPnts > nrTaps + 1)
      FIRStartDelay = 21 * MaxSpeed
   else
      FIRStartDelay = 2 * nrPnts * MaxSpeed
   endif
   
   CICDelay = 10 * (CIC_Scale + 71 + (3 * MaxSpeed)) / 1000
   FIRDelay = 10 * (50 + FIRScale + FIRStartDelay) / 1000
   
   if(useFIRFilter)
      acqTm = (nrPnts + ignorePnts) * dwellTime + CICDelay + FIRDelay
   else
      # Make allowances for CIC shift register delays - how to calculate these values?
      scaleDwellTime = [0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000]
      scaleDelay = [0.11, 0.15, 0.19, 0.27, 0.31, 0.35, 0.39, 0.43, 0.47, 0.51, 0.55, 0.59] + 0.32
      indx = findindex(scaleDwellTime,dwellTime)
      CICScaleDelay = scaleDelay[indx]
      CICScaleDelay = 1 #scaleDelay[indx]
      acqTm = (nrPnts + ignorePnts) * dwellTime + CICDelay + CICScaleDelay
   endif

endproc(acqTm+1)