#########################################################
# 
# CPMGInt
#
# CPMG pulse sequence in which each echo is summed to 
# return a single complex number per echo.
#
# 90 - delay - {180 - delay - acq}
#
# Copyright (c) Magritek Ltd 2025
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the KeaExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(CPMGInt, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"CPMGInt")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("CPMGInt")
   else
      gExpt->addExperiment(parentPath,"CPMGInt",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds [""] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["nxShim = 0",
          "nyShim = 0",
          "nzShim = 0",
          "noShim = 0",
          "a90      = 90AmplitudeCh1",
          "a180     = 180AmplitudeCh1",
          "dRF      = pulseLengthCh1",
          "d90_180  = echoTime/2-dRF/2-pgo-2",
          "d180_acq = echoTime/2-acqTime*500-dRF/2+rxLat-1+echoShift",
          "dAcq     = echoTime-dRF-pgo-d180_acq-2",
          "nEchoes  = nrEchoes",
          "nPnts    = nrPnts",
          "totPnts  = nrEchoes",
          "totTime  = echoTime*nrEchoes"]
   var = [""]
   pp_list = ["nEchoes","a90","p1","dRF","d90_180","l1","a180","p2","d180_acq","nPnts","dAcq"]
   pp_name = "CPMGInt.p"
   phase_list = [2,0,2,0;3,1,1,3;2,0,2,0]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)

#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

   guipar = guipar + ["timeMag = \"no\"",
                      "showTimeDomain = \"yes\"",
                      "showFreqDomain = \"yes\""]

# Make all gui parameters available
   assignlist(guipar)

# Do some safety checks
   if(d90_180 < 1 | d180_acq < 1 | dAcq < 1)
      message("Error","Pulse sequence timing error!\rReduce acquisition time or increase echotime.","error")
      return(0)
   endif

   if(dAcq-ucsRun:getAcqTime(guipar) <= 0)
      message("Error","Pulse sequence timing error!\rReduce acquisition time or increase echotime.","error")
      return(0)
   endif

# # Check RF duty cycle
#   if(ucsRun:highDutyCycle(dRF*nEchoes,nEchoes*echoTime,guipar))
#      return(0)
#   endif

# Allocate data for outputs
   sumData = cmatrix(totPnts)
   sumDataAP = cmatrix(totPnts)
   fitTxt = ""

# Calculate a suitable time axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime + echoTime

# Make plot regions.
   (pt1,pt2) = ucsPlot:getPlotReferences()

# Accumulate scan
   for(scan = -dummies to nrScans-1)

    # Set phases for this scan
      (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)

    # Send all parameter values to Spectrometer
       ucsRun:updatePPParameters(ppList,guipar)

    # Wait for the repetition time to complete
      check = ucsRun:checkTiming(guipar,scan,pcList)
      if(check == "abort")
         return(0)
      endif

    # Collect the data
      (status,data) = ucsRun:getData(totPnts,guipar)
      if(status != "ok")
         return(0)
      endif

      if(scan < 0)
          
         pt1->draw("false")
         pt1->plot(matrix(totPnts))
         pt1->title("Dummy scan $-scan$")
         pt1->draw("true")

      else
   
       # Accumlate the data
         sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)

      # Plot the integrals
         if(fitType == "none" | fitMode == "manual")
   
            if(autoPhase == "yes")
               (ph,sumDataAP) = ucsRun:autoPhase(sumData/nrPnts,phaseMethod)
            else
               sumDataAP = sumData/nrPnts
            endif

          # Display the data
            ucsPlot:graphTime(pt1,tAxis/1000,sumDataAP,scan,guipar,
                             "Echo integrals SCANS","Time (ms)","Average echo amplitude (\G(m)V)")

            # Display the SNR
            if(scan >= 0  & ((scan+1) % size(pcList) == 0))
               :displaySNR(sumDataAP)
            endif

         else
   
            if(scan >= 0  & ((scan+1) % size(pcList) == 0)) # Only display fit after full phase cycle.
            # Autophase is desired
               if(autoPhase == "yes")
                  (ph,sumDataAP) = ucsRun:autoPhase(sumData/nrPnts,phaseMethod)
               else
                  sumDataAP = sumData/nrPnts
               endif
   
            # Plot the integral data 
               ucsPlot:graphTime(pt1,tAxis/1000,sumDataAP,scan,guipar,
                                "Echo integrals SCANS","Time (ms)","Average echo amplitude (\G(m)V)")
   
            # Do a fit if requested
               rData = real(sumDataAP)/(scan+1)
               if(fitType == "nnls")
                  fitTxt = :DisplayFit(pt1,pt2,tAxis,rData,nrEchoes,guipar)
               else
                  fitTxt = :DisplayFit(pt2,pt2,tAxis,rData,nrEchoes,guipar)
               endif

            # Display the SNR
               :displaySNR(sumDataAP)
   
            endif # Full phase cycle
   
         endif # Fit type

      endif # Dummy scans

    # Check if complete button pressed
      if(check == "finish")
         scan = scan+1
         exitfor()
      endif

   next(scan)

# Print result
   if(fitTxt != "")
     pr("$fitTxt$")
   endif

# Save the data
  ucsFiles:savePlot(pt1,:getPlotInfo("pt1"),guipar,"simpleReport")
  ucsFiles:savePlot(pt2,:getPlotInfo("pt2"),guipar,"simpleReport")

# Return result structure when called from backdoor
   result = struct()
   result->tx = tAxis/1000
   result->ty = sumDataAP/scan

   return(result)

endproc("execpp") # Don't remove argument


###################################################################
#
# Display the passed data points and a fitted t2 curve
#
# Parameters are:
# x ........ the time array
# y ........ the amplitude arrays
# N ........ the number of data points to plot
# guipar ... GUI parameter list
#
###################################################################
 

procedure(DisplayFit,pt2,pt3,x,y,N,guipar)

  assignlist(guipar)

   if(fitType == "nnls")
      result = :ILFit(pt2,pt3,x/1000,y,N,guipar)
   else
      result = ucsPlot:fitAndGraph(pt2,x/1000,real(y),N,fitType,null,
                                   "Time (ms)","Echo integral (UNITS)",
                                   "Echo attenuation data",
                                   "Fit result: RESULT",guipar)

  endif

endproc(result)


###################################################################
#
# Display the passed data points and a fitted relaxation curve
# and relaxation spectrum
#
# Parameters are:
# x ....... the time array
# y ....... the amplitude arrays
# N ....... the number of data points to plot
# guipar ... GUI parameter list
#
###################################################################
 
procedure(ILFit,pt2,pt3,x,y,N,guipar)

   assignlist(guipar)

# Bin the data if more than 100 points
   if(N > 100)
      x_steps = 100 
     (timeDat,yData) = pseudologbin(x,y,100)
   else
     timeDat = x
     yData   = y
     x_steps = N-1
   endif

# Invert meaning of alpha and reduce range
   alpha = 10^(8-log10(alpha))

   guipar = guipar + ["exp_type = \"exp(-t/T)\"",
          "designMat = \"exp(-xData'*(1/xSpec))\"",
          "alpha = $alpha$",
          "logBin = \"true\"",
          "weightBins = \"true\"",
          "x_steps = $x_steps$"]

# Invert using Lawson and Hanson inverstion
   (specX,specY) = LHInvert(x,y,guipar)

# Get fit parameters
  (fit,chisq) = LHInvert:calcFit("exp(-t/T)",specX,specY,x,y)

# Plot original data with L&H fit
   ucsPlot:graphXYFit(pt2,x,y,fit,null,size(x),
                      "Time (ms)","Average echo amplitude (UNITS)","Echo attenuation data (with IL fit)",guipar)

   guipar = guipar + ["xMap = \"log\"",
                      "traceCol = $wvSpectrumColor$",
                      "symbolShape = \"none\""]

# Plot the spectrum
   ucsPlot:graphXY(pt3,specX,specY,null,size(specX),
                      "log_(10)(T) ms","Amplitude","Relaxation Spectrum",guipar)

endproc("")


###################################################################
#
# Apply a fit to the data set by pressing the fit button
#
###################################################################
 
procedure(applyFit)

   guipar = getctrlvalues(0)
   assignlist(guipar)

# If GUI has been run without collecting data first
# then need to load in various Kea parameters
   par = ucsFiles:loadPref()
   assignlist(par)
   windowvar(wvDataSymbolColor,wvDataSymbolShape,wvFitCurveColor,wvSpectrumColor,wvUnits)
   wvDataSymbolColor = dataSymbolColor
   wvDataSymbolShape = dataSymbolShape
   wvFitCurveColor = fitColor
   wvSpectrumColor = spectrumColor
   wvUnits = units
   guipar = mergelists(guipar,par)    

   (pt1,pt2) = ucsPlot:getPlotReferences()

# Get raw CPMG data
   (x,y) = pt1->getdata()

   curplot(pt2)

# Autophase if requested
   if(autoPhase == "yes")
     (txt,lx,ly) = 1dpar:get()
      (ph,y) = ucsRun:autoPhase(y,phaseMethod)
      n = findobj(0,"name","rxPhase")
      phOld = getpar(0,n,"value")
      setpar(0,n,"text",phOld+ph)
   endif

   N = size(x)

# Get the current plot organisation
   (nx,ny) = pt2->parent->size()

pr local

# Do the requested fit
   if(fitType == "nnls")
      if(nx != 2)
        (pta,ptb) = pt2->parent->multiplot(2,1)
      else
         pta = pt2->parent->subplot(1,1)
         ptb = pt2->parent->subplot(2,1)
      endif

      result = :ILFit(pta,ptb,x,real(y),N,guipar)
      pt2 = pta
      pt2->fileName(:getPlotInfo("pt2"))
      pt2->filePath(gData->curExpt->dataPath)

   elseif(fitType == "none")

        pt2->parent->multiplot(1,1)
        result = ""

   else

      if(nx != 1)
        pta = pt2->parent->multiplot(1,1)
      else
         pta = pt2->parent->subplot(1,1)
      endif
      result = ucsPlot:fitAndGraph(pta,x,real(y),N,fitType,null,
                                   "Time (ms)","Echo integral (UNITS)",
                                   "Echo attenuation data",
                                    "Fit result: RESULT",guipar)

      pta->fileName(:getPlotInfo("pt2"))
      pta->filePath(gData->curExpt->dataPath)

   endif

# Print result
  if(result != "")
    pr("$result$")
   endif

endproc()

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt1","rawCPMG.pt1","pt2","fit.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)


########################################################
# Return expected experiment duration in seconds
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = dummies + nrScans + useStartDelay
   duration = (totScans*repTime)/1000

endproc(duration)


########################################################
# Display the signal to noise ratio
########################################################

procedure(displaySNR, data)

   if(isvar("curSNRCtrl"))
      ns = imag(data)
      ns = ns[round(size(ns)/2):-1]
      rms = ucsRun:stdDev(ns) # Noise is RMS of last half of data set
      sig = real(data[0])
      curSNRCtrl->text("$sig/rms,1.1f$")
   endif
 
endproc()
