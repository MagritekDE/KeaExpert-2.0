#########################################################
# 
# CPMGAdd
#
# CPMGAdd pulse sequence with dummy pulses
# (following a dummy 180-pulse data is not collected)
#
# 90 - delay - {180 - delay - acq - {180 - delay}}
#
# Copyright (c) Magritek Ltd 2025
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the KeaExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(CPMGAdd, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"CPMGAdd")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("CPMGAdd")
   else
      gExpt->addExperiment(parentPath,"CPMGAdd",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds [""] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["nxShim = 0",
          "nyShim = 0",
          "nzShim = 0",
          "noShim = 0",
          "a90            = 90AmplitudeCh1",
          "a180           = 180AmplitudeCh1",
          "dRF            = pulseLengthCh1",
          "d90_180        = echoTime/2-dRF/2-pgo-2",
          "d180_acq       = echoTime/2-acqTime*500-dRF/2+rxLat-1+echoShift",
          "dAcq           = echoTime-dRF-pgo-d180_acq-2",
          "dAcq2          = dAcq+1",
          "dDummy         = echoTime-dRF-pgo-2",
          "nEchoes        = nrEchoes",
          "nPnts          = nrPnts",
          "nZeroDummy     = (dummyEchoes==0)",
          "nOneDummy      = (dummyEchoes==1)",
          "nManyDummies   = (dummyEchoes>1)",
          "nDummies       = dummyEchoes-1",
          "totPnts        = nrPnts",
          "totTime        = nrEchoes*echoTime*(dummyEchoes+1)"]
   var = [""]
   pp_list = ["nxShim","nyShim","nzShim","noShim","nPnts","nZeroDummy","s1","a90","p1","dRF","d90_180","nEchoes","l1","a180","p2","d180_acq","dAcq","nOneDummy","s2","l2","dAcq2","dDummy","nManyDummies","s3","l3","nDummies","l4"]
   pp_name = "CPMGAdd.p"
   phase_list = [2,0,2,0;3,1,1,3;2,0,2,0]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)

#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
########################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

   guipar = guipar + ["showTimeDomain = \"yes\"",
                      "showFreqDomain = \"yes\""]

# Make all gui parameters available
   assignlist(guipar)

# Do some safety checks
   if(d90_180 < 1 | d180_acq < 1 | dAcq < 1 | dDummy < 1)
      message("Error","Pulse sequence timing error 1!\rReduce acquisition time or increase echotime.","error")
      return(0)
   endif

   if(dAcq-ucsRun:getAcqTime(guipar) <= 0)
      message("Error","Pulse sequence timing error 2!\rReduce acquisition time or increase echotime.","error")
      return(0)
   endif

 # Check RF duty cycle
   if(ucsRun:highDutyCycle(dRF*nEchoes,nEchoes*echoTime,guipar))
      return(0)
   endif

# Check for too much data
   if(nrPnts > 4096)
      message("Error","Parameter error!\rReduce number of points per echo <= 4096.","error")
      return(0)
   endif

# Calculate a suitable time axis
   tAxis = [0:1:nrPnts-1]/(nrPnts)*acqTime
   totalTime = ([0:1:totPnts-1]/totPnts)*totTime + echoTime

# Allocate memory for outputs
   echoData   = cmatrix(totPnts)
   echoData2D = cmatrix(nrPnts,nrEchoes)
   ampArray   = matrix(nrEchoes)
   tauArray   = matrix(nrEchoes)
   echoSum    = cmatrix(nrPnts)
   fltTot     = matrix(nrPnts,nrEchoes)

# Filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",nrPnts)
      for(ec = 0 to nrEchoes-1)
         fltTot[~,ec] = flt
      next(ec)
      fltTot = reshape(fltTot,totPnts,1)
   else
      flt = matrix(nrPnts)+1
      fltTot = matrix(totPnts)+1
   endif


# Get the plot references
   pt1 = ucsPlot:getPlotReferences()

# Intialise phase
   ph = 0

# Accumulate scan
   for(scan = -dummies to nrScans-1)

    # Set phases for this scan
      (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)

    # Send all parameter values to Spectrometer
       ucsRun:updatePPParameters(ppList,guipar)

    # Wait for the repetition time to complete
      check = ucsRun:checkTiming(guipar,scan,pcList)
      if(check == "abort")
         return(0)
      endif

    # Collect the data
      (status,data) = ucsRun:getData(totPnts,guipar)
      if(status != "ok")
         return(0)
      endif

      if(scan < 0)
          
         pt1->draw("false")
         pt1->plot(matrix(totPnts))
         pt1->title("Dummy experiment $-scan$")
         pt1->draw("true")

      else
   
       # Accumlate the data
         echoData = ucsRun:accumulate(accumulate,pAcq,echoData,data)
   
      # Autophase if desired
         if(autoPhase == "yes")
            if(((scan+1) % size(pcList) == 0))
              ph = ucsRun:autoPhase(echoData,"maxreal")
              ph = ph*pi/180
            endif
         endif
    
      # Display full time domain data
         ucsPlot:graphTime(pt1,tAxis*1000,echoData.*fltTot*exp(i*ph),scan,guipar,
                           "CPMGAdd echo SCANS","Acquisition time (\G(m)s)")

       endif # Dummy scans

    # Check if complete button pressed
      if(check == "finish")
         scan = scan+1
         exitfor()
      endif

   next(scan)

# Update Rx Phase textbox in GUI
   if(autoPhase == "yes")
      try
         n = findobj(0,"name","rxPhase")
         phOld = getpar(0,n,"value")
         phNew = ((ph*180/pi)+phOld)%360
         setpar(0,n,"text",phNew)
      catch
      endtry
   endif

# Save the data
   ucsFiles:savePlot(pt1,:getPlotInfo("pt1"),guipar,"noReport")

# Return the data
   result = struct()
   result->echo = 1000*echoData*exp(i*ph)/nrScans

# Return result structure when called from backdoor
   return(result)

endproc("execpp")


########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt1","rawCPMGAdd.pt1","pt2","summedCPMGAdd.pt1","im1","CPMGAddEchoes.pt2"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)


###################################################################
#
# Display time domain data in the 2D plot
#
# Parameters are:
# echoData2D ... the data to display
# guipar ....... the window parameters
#
###################################################################
 
procedure(display2DData, pd,echoData2D,guipar)

   assignlist(guipar)

   tmax = acqTime*1000 

   pd->draw("false")
      pd->image(echoData2D,[0,tmax],[0,(dummyEchoes+1)*nrEchoes*echoTime])
      pd->title("CPMGAdd echoes (complex)")
      pd->ylabel("echo time (\G(m)s)")
      pd->xlabel("Acquisition time (\G(m)s)")
   pd->draw("true")

endproc()

###################################################################
#
# Display the passed data points and a fitted t2 curve
#
# Parameters are:
# x ........ the time array
# y ........ the amplitude arrays
# N ........ the number of data points to plot
# guipar ... GUI parameter list
#
###################################################################
 

procedure(DisplayFit,pt2,pt3,x,y,N,guipar)

  assignlist(guipar)

   if(fitType == "nnls")
      result = :ILFit(pt2,pt3,x/1000,y,N,guipar)
   else
      result = ucsPlot:fitAndGraph(pt2,x/1000,y,N,fitType,null,
                          "Time (ms)","Echo integral (UNITS)",
                          "Echo attenuation data",
                          "Fit result: RESULT",guipar)
  endif

endproc(result)


###################################################################
#
# Display the passed data points and a fitted relaxation curve
# and relaxation spectrum
#
# Parameters are:
# x ....... the time array
# y ....... the amplitude arrays
# N ....... the number of data points to plot
# guipar ... GUI parameter list
#
###################################################################
 
procedure(ILFit,pt2,pt3,x,y,N,guipar)

   assignlist(guipar)

# Bin the data if more than 100 points
   if(N > 100)
      x_steps = 100 
     (timeDat,yData) = pseudologbin(x,y,100)
   else
     timeDat = x
     yData   = y
     x_steps = N-1
   endif

# Invert meaning of alpha and reduce range
   alpha = 10^(8-log10(alpha))

   guipar = guipar + ["exp_type = \"exp(-t/T)\"",
          "designMat = \"exp(-xData'*(1/xSpec))\"",
          "alpha = $alpha$",
          "logBin = \"true\"",
          "weightBins = \"true\"",
          "x_steps = $x_steps$"]

# Invert using Lawson and Hanson inverstion
   (specX,specY) = LHInvert(x,y,guipar)

# Get fit parameters
  (fit,chisq) = LHInvert:calcFit("exp(-t/T)",specX,specY,x,y)

# Plot original data with L&H fit
   ucsPlot:graphXYFit(pt2,x,y,fit,null,size(x),
                      "Time (ms)","Average echo amplitude (UNITS)","Echo attenuation data (with IL fit)",guipar)

   guipar = guipar + ["xMap = \"log\"",
                      "traceCol = $wvSpectrumColor$",
                      "symbolShape = \"none\""]
# Plot the spectrum
   ucsPlot:graphXY(pt3,specX,specY,null,size(specX),
                      "log_(10)(T) ms","Amplitude","Relaxation Spectrum",guipar)

endproc("")


########################################################
# Update the progress bar and experiment times
########################################################

procedure(updateProgress, scans, guipar)

# Define progress/timing expressions

   if(isvar("progressCtrl"))

      assignlist(guipar)

      if(scans == -1)
         curSNRCtrl->text("-")
      endif

      repTime = ieTime + nrEchoes*echoTime/1000

   # Define progress/timing expressions
      totTime = (nrScans+dummies)*repTime/1000
      expTime = (scans+1)*repTime/1000
      remTime = totTime - expTime
      progress = 100*expTime/totTime

   # Update controls
     ucsCtrl:updateProgress(scans+1-dummies,progress,totTime,expTime,remTime)

   endif

endproc()


########################################################
# Return expected experiment duration in seconds
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = nrScans + useStartDelay
   duration = (totScans*repTime)/1000

endproc(duration)



