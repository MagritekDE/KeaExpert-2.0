#########################################################
# 
# Wobble
#
# Frequency sweep pulse program used for probe tuning
# on the internal duplexer
#
# Copyright (c) Magritek Ltd 2025
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the KeaExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(Wobble, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"Wobble")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("Wobble")
   else
      gExpt->addExperiment(parentPath,"Wobble",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds [""] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["nPnts      = nrPnts",
          "b1FreqCh1  = centFreq-freqWidth/2",
          "fSweep     = linspace(b1FreqCh1,b1FreqCh1+freqWidth,nFreqSteps)",
          "tFreq1     = gFX3->convertFrequency(fSweep)",
          "tFreq2     = gFX3->convertFrequency(fSweep*10)",
          "totPnts    = nFreqSteps",
          "dStab      = 60",
          "dRecover   = 2000",
          "totTime    = acqTime",
          "specialMode = \"wobble\""]
   var = [""]
   pp_list = ["nFreqSteps","tFreq1","tFreq2","l1","aRF","p1","dStab","nPnts","dRecover"]
   pp_name = "Wobble.p"
   phase_list = [0;0]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)


#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
# June 2022
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)

# Calculate suitable frequency axes
   freqAxis = linvec(centFreq-freqWidth/2,centFreq+freqWidth/2,nFreqSteps)

# Storage for accumulated data
   sumData = cmatrix(nFreqSteps)

# Make one subplot
   prf = ucsPlot:getPlotReferences()

# Accumulate scan
   for(scan = 0 to nrScans-1)

    # Note the time at scan start
      t1 = time()  

    # Set phases for this scan
      (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)

    # Send phase parameters to DSP
      ucsRun:updatePPParameters(ppList,guipar,wvPort)  

    # Collect the data
      (status,data) = ucsRun:getData(totPnts,guipar)

      if(status != "ok")
         :resetRelay()
         return(0)
      endif
   
      if(scan >= 0) # The first scan won't be displayed as this sets the relay

         #data = :averagePoints(data,nFreqSteps)

       # Accumlate the data
         sumData = ucsRun:accumulate(accumulate,0,sumData,data)

       # Graph the data
         :graphData(prf, mag(sumData/nrPnts),single(freqAxis),scan,guipar)

         # Check timing
         check = ucsRun:checkTimeAndAbort(guipar,t1,scan,pcList)
         if(check == "abort")
            :resetRelay()
            return(0)
         elseif(check == "finish")
            scan = scan + 1
            exitfor()
         endif

      endif

   next(scan)

# Reset the wobble relay
   :resetRelay()

# Save data
   ucsFiles:savePlot(prf,:getPlotInfo("pt1"),guipar,"simpleReport")

# Return data
   result = struct()
   result->fx = freqAxis
   result->fy = sumData/scan

   return(result)

endproc("execpp")

########################################################
#  Reset the duplexer relay
########################################################

procedure(resetRelay)

   if(gData->procType == "FX3")
       fx3write("E", 0x00, [0])
   else
      dir = getcwd()
      cd("$appdir$\\Macros\\UCS-Core\\resetDSP")
      pp = dspreadpp("reset.p")
      dspwrite("p",0x2000,pp,wvPort)
      dsprunpp(0x2000,wvPort)
      cd(dir)
   endif

endproc()


########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt1","wobbleResponse.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)


###################################################################
#
# Graph the signal in the time domain
#
# Input: fidData ........ signal
#        t .............. time domain vector
#        n .............. number of scans accumulated
#        guipar ......... parameters extracts from dialog 
#
###################################################################

procedure(graphData, pd, fidData,f,n,guipar)

   assignlist(guipar)

# Allow for accumulations
   if(accumulate == "yes")
      sf = 1/(n+1)
   else
      sf = 1
   endif

# Select units
   if(wvUnits == "uV")
      timeUnits = "\G(m)V"
      freqUnits = "\G(m)V/kHz"
      ampMin = wvTimeMin
      ampMax = wvTimeMax
   else
      timeUnits = "mV"
      freqUnits = "mV/kHz"
      ampMin = wvTimeMin
      ampMax = wvTimeMax
   endif

# Select y label
   if(wvApplyPreampFactor == "yes")
      yTxt = "Probe reflected amplitude"
   elseif(wvApplyRxampFactor == "yes")
      yTxt = "Rx Amp input amplitude"
   else
      yTxt = "Transceiver input amplitude"
   endif

 # Display frequency domain data
   pd->draw("false")

    # Find minimum and maximum
      dat = mag(fidData*sf)
      (valMin,xMin) = min(dat)
      (valMax,xMax) = max(dat)

      pd->plot(f,mag(fidData*sf))
      pd->title("Probe amplitude reflection vs. frequency (minimum at $f[xMin],2.4f$ MHz)")
      pd->xlabel("Frequency (MHz)")
      pd->ylabel("$yTxt$ ($timeUnits$)")

      if(fixedAmp == "yes")
         if(logScale == "no")
            pd->axes("ymapping","lin")
            pd->zoom(min(f),max(f),0,valMax*1.2)
         else
            pd->axes("ymapping","log")
            pd->zoom(min(f),max(f),maxAmp/(10^nrDecades),maxAmp)
         endif
      endif

      pd->hold("on")

      (minx,maxx,miny,maxy) = pd->zoom()

    # Draw vertical line
      lineX = [centFreq, centFreq]
      lineY = [miny,maxy]

      pd->plot(lineX,lineY,"tracecolor",[200,200,200])

      pd->zoom(minx,maxx,miny,maxy)

      pd->hold("off")

   pd->draw("true")

endproc()

###################################################################
# Average over the number of points per step returning
# nFreqSteps of data
###################################################################

procedure(averagePoints, data, nrSteps)

   nrPnts = size(data)/nrSteps
   data = mag(data)
   dataOut = matrix(nrSteps)
   for(k = 0 to nrSteps-1)
      dataOut[k] = sum(data[k*nrPnts:k*nrPnts+nrPnts-1])
   next(k)

endproc(dataOut)

