#########################################################
# 
# CPMGDurationSweep
#
# CPMG pulse sequence in which each echo is summed to 
# return a single complex number per echo.
# The duration of the RF pulses is then stepped to find
# the optimal 90/180 combination
#
# 90 - delay - {180 - delay - acq}
#
# Copyright (c) Magritek Ltd 2025
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the KeaExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(CPMGDurationSweep, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"CPMGDurationSweep")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("CPMGDurationSweep")
   else
      gExpt->addExperiment(parentPath,"CPMGDurationSweep",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds ["dRF","d90_180","d180_acq","dAcq"] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["nxShim = 0",
          "nyShim = 0",
          "nzShim = 0",
          "noShim = 0",
          "a90      = 90AmplitudeCh1",
          "a180     = 180AmplitudeCh1",
          "dRF      = minWidth",
          "d90_180  = echoTime/2-dRF/2-pgo-2",
          "d180_acq = echoTime/2-acqTime*500-dRF/2+rxLat-1+echoShift",
          "dAcq     = echoTime-dRF-pgo-d180_acq-2",
          "nEchoes  = nrEchoes",
          "nPnts    = nrPnts",
          "totPnts  = nrEchoes",
          "totTime  = echoTime*nrEchoes"]
   var = ["dRF","d90_180","d180_acq","dAcq"]
   pp_list = ["nxShim","nyShim","nzShim","noShim","a90","p1","dRF","d90_180","nEchoes","l1","a180","p2","d180_acq","nPnts","dAcq"]
   pp_name = "CPMGDurationSweep.p"
   phase_list = [2,0,2,0;3,1,1,3;2,0,2,0]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)

#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)

# Do some safety checks
   if(d90_180 < 1 | d180_acq < 1 | dAcq < 1)
      message("Error","Pulse sequence timing error!\rReduce acquisition time or increase echotime.","error")
      return(0)
   endif

   if(dAcq-ucsRun:getAcqTime(guipar) <= 0)
      message("Error","Pulse sequence timing error!\rReduce acquisition time or increase echotime.","error")
      return(0)
   endif

# # Check RF duty cycle
#   if(ucsRun:highDutyCycle(dRF*nEchoes,nEchoes*echoTime,guipar))
#      return(0)
#   endif

# Allocate data for outputs
   durationAxis = linspace(minWidth, minWidth + (nrSteps-1)*widthStep, nrSteps)
   specInt = matrix(nrSteps)

# Calculate a suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime + echoTime # us
   fAxis = ([0:1:totPnts-1]-totPnts/2)/totTime*1e6 # Hz

# Make plot regions.
   (pt1,pt2,pt3) = ucsPlot:getPlotReferences()

# Step over pulse length
   for(stp = 0 to nrSteps-1)

   #  Update the various delays as the pulse length is modified
      dRF      = minWidth + stp*widthStep
      d90_180  = echoTime/2-dRF/2-pgo-2
      d180_acq = echoTime/2-acqTime*500-dRF/2+rxLat-1+echoShift
      dAcq     = echoTime-dRF-pgo-d180_acq-2
      
      ppList = ucsRun:setPPDelay(ppList,varIndex[0],dRF)
      ppList = ucsRun:setPPDelay(ppList,varIndex[1],d90_180)
      ppList = ucsRun:setPPDelay(ppList,varIndex[2],d180_acq)
      ppList = ucsRun:setPPDelay(ppList,varIndex[3],dAcq)

      # Initialize the CPMG data array
      sumData = cmatrix(totPnts)

   # Accumulate scans using these parameters
      for(scan = 0 to nrScans-1)
   
       # Set phases for this scan
         (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)
   
       # Send all parameter values to Spectrometer
          ucsRun:updatePPParameters(ppList,guipar)
   
       # Wait for the repetition time to complete
         check = ucsRun:checkTiming(guipar,scan,pcList)
         if(check == "abort")
            return(0)
         endif
   
       # Collect the data
         (status,data) = ucsRun:getData(totPnts,guipar)
         if(status != "ok")
            return(0)
         endif
   
       # Accumlate the data
         sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)

       # Autophase
         if(autoPhase == "yes")
            (ph,sumDataAP) = ucsRun:autoPhase(sumData/nrPnts,"minsd")
         else
            sumDataAP = sumData/nrPnts
         endif

       # Process the data
        (phasedTimeData,spectrum) = ucsRun:transformData(sumDataAP,fAxis,guipar,"fid",1)

       # Display the data
        # ucsPlot:graphTimeAndFreq(pt1,pt2,tAxis,sumDataAP,fAxis,spectrum,scan,guipar,"CPMGInt Scan $scan+1$/$nrScans$ Pulse-width: $dRF$ \G(m)s")

         ucsPlot:graphTimeAndFreq(pt1,pt2,tAxis,sumDataAP,fAxis,spectrum,scan,guipar,
                                  "CPMGInt Scan: $scan+1$/$nrScans$, Pulse-width: $dRF$ \G(m)s", "CPMG Spectrum",
                                  "Time (ms)", "CPMGInt amplitude (\G(m)V)","Frequency (Hz)", "Amplitude (\G(m)V/Hz)")
                                  


       # Check if complete button pressed
         if(check == "finish")
            scan = scan+1
            exitfor()
         endif
   
      next(scan)

     # Integrate the spectrum to get the initial CPMG amplitude
      specInt[stp]  = integvector(fAxis,real(spectrum)/nrScans,-intWidth/2,intWidth/2)

     # Plot the integrals
      ucsPlot:graphXY(pt3,durationAxis,specInt,null,stp+1,
                     "Pulse Duration (\G(m)s)","Peak Integral",
                     "Pulse Duration Analysis",guipar)

     # Check if complete button pressed
      if(check == "finish")
         scan = scan+1
         exitfor()
      endif

   next(pulseStep)


# Save the data
  ucsFiles:savePlot(pt3,:getPlotInfo("pt3"),guipar,"simpleReport")

# Return result structure when called from backdoor
   result = struct()
   result->x = durationAxis
   result->y = specInt

   return(result)

endproc("execpp") # Don't remove argument

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt3","CPMGDurSweep.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)


########################################################
# Return expected experiment duration in seconds
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = (nrScans + useStartDelay)*nrSteps
   duration = (totScans*repTime)/1000

endproc(duration)

