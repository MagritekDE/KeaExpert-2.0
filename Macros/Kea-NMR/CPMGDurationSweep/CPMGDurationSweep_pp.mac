########################################################
#
# CPMG pulse sequence in which each echo is summed to 
# return a single complex number per echo.
# The duration of the RF pulses is then stepped to find
# the optimal 90/180 combination
#
# 90 - delay - {180 - delay - acq}
#
########################################################

procedure(pulse_program,dir,mode,pars)

# Expose parameters for FX3 implementation
   if(nrArgs == 3)
      assignlist(pars)
   endif

# Interface description (name,   label, ctrlType, varType)
  interface = ["b1FreqCh1",      "B1 Frequency (MHz)",     "tb",  "freq";
               "90AmplitudeCh1", "90 amplitude (dB)",      "tb",  "float,[-85,-6]";
               "180AmplitudeCh1","180 amplitude (dB)",     "tb",  "float,[-85,0]";
               "minWidth",       "Min. pulse length (us)", "tb",  "float,[0.5,100]";
               "widthStep",      "Pulse width step (us)",  "tb",  "float,[0.5,100]";
               "nrSteps",        "Number of steps",        "tb",  "integer,[2,100]";
               "echoTime",       "Echotime (us)",          "tb",  "sdelay";
               "nrEchoes",       "Number of echoes",       "tb",  "integer,[0,50000]";
               "echoShift",      "Echo shift",             "tb",   "float,[-50,50]";
               "intWidth",       "Integration width (Hz)", "tb",  "integer,[1,100000]";
               "repTime",        "Repetition time (ms)",   "tb",  "reptime"]


# Relationships to determine remaining variable values
   relationships = ["nxShim = 0", #xcal*xshim/1000", # x shim value
                    "nyShim = 0", #ycal*yshim/1000", # y shim value
                    "nzShim = 0", #zcal*zshim/1000", # z shim value
                    "noShim = 0", #ocal*oshim/1000", # o shim value
                    "a90      = 90AmplitudeCh1",
                    "a180     = 180AmplitudeCh1",
                    "dRF      = minWidth",
                    "d90_180  = echoTime/2-dRF/2-pgo-2",
                    "d180_acq = echoTime/2-acqTime*500-dRF/2+rxLat-1+echoShift",
                    "dAcq     = echoTime-dRF-pgo-d180_acq-2",
                    "nEchoes  = nrEchoes",
                    "nPnts    = nrPnts",
                    "totPnts  = nrEchoes",
                    "totTime  = echoTime*nrEchoes"]

# Define the tabs and their order
   tabs = ["Pulse_sequence","Progress","Acquisition","Processing_Autophase","File_Settings"]

# These parameter(s) will be changed between experiments
   variables = ["dRF","d90_180","d180_acq","dAcq"]

# Pulse sequence
   initpp(dir) # Reset internal parameter list

   gradon(x,nxShim)                    # Set x shim
   gradon(y,nyShim)                    # Set y shim
   gradon(z,nzShim)                    # Set z shim 
   gradon(o,noShim)                    # Set o shim 

   pulse(mode,a90,p1,dRF)              # 90 RF pulse
   delay(d90_180)                      # 90 - 180 delay
   loop(l1,nEchoes)
      pulse(mode,a180,p2,dRF)          # 180 RF pulse
      delay(d180_acq)                  # 180 - acq delay
      acquire("integrate",nPnts,dAcq)  # Acquire echo and wait
   endloop(l1)

   lst = endpp(0) # Return parameter list

# Phase cycle
   phaseList = [2,0,2,0; # -x,x,-x,x : 90 phase
                3,1,1,3; # -y,y,y,-y : 180 phase
                2,0,2,0] # -x,x,-x,x : Acquire phase

endproc(lst,tabs,interface,relationships,variables,0,phaseList)

#####################################################
# Assign those parameters which should take their 
# values from the factory defaults when making a 
# new experiment
#####################################################

procedure(getFactoryBasedParameters, par)

   specPar = KeaParameterUpdater:readSpecPar()
   if(specPar == null)
      return(null)
   endif
   assignlist(specPar)

   par = ["rxGain          = $rxOptGaindB$",
          "90AmplitudeCh1  = $pulseAmplitudeCh1$",
          "180AmplitudeCh1 = $pulseAmplitudeCh1$+6",
          "b1FreqCh1       = $frequencyCh1$"]

endproc(par)

