#########################################################
# 
# SpinEcho
#
#
# SpinEcho pulse sequence 
#
# 90 - delay - 180 - delay - acq 
#
# Copyright (c) Magritek Ltd 2025
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the KeaExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(SpinEcho, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"SpinEcho")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("SpinEcho")
   else
      gExpt->addExperiment(parentPath,"SpinEcho",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds [""] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["nxShim         = 0",
          "nyShim         = 0",
          "nzShim         = 0",
          "noShim         = 0",
          "a90            = 90AmplitudeCh1",
          "a180           = 180AmplitudeCh1",
          "dRF            = pulseLengthCh1",
          "d90_180        = echoTime/2-dRF/2-pgo-2",
          "d180_acq       = 100",
          "dAcq           = echoTime-dRF-pgo-d180_acq-2",
          "nPnts          = nrPnts",
          "totPnts        = nrPnts",
          "totTime        = acqTime"]
   var = [""]
   pp_list = ["nxShim","nyShim","nzShim","noShim","a90","p1","dRF","d90_180","a180","p2","d180_acq","nPnts"]
   pp_name = "SpinEcho.p"
   phase_list = [2,0,2,0;3,1,1,3;2,0,2,0]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)

#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
########################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

   guipar = guipar + ["showTimeDomain = \"yes\"",
                      "showFreqDomain = \"yes\""]

# Make all gui parameters available
   assignlist(guipar)

# Do some safety checks
   if(d90_180 < 1 | d180_acq < 1)
      message("Error","Pulse sequence timing error 1!\rReduce acquisition time or increase echotime.","error")
      return(0)
   endif

# Calculate a suitable time axis
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000   # (us)
   fAxis = ([0:1:totPnts-1]-totPnts/2)/totTime*1000 # (Hz)

# Allocate memory for outputs
   echoData   = cmatrix(totPnts)
   ampArray   = matrix(nrEchoes)
   tauArray   = matrix(nrEchoes)
   echoSum    = cmatrix(nrPnts)

# Filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",tAxis/1e6)
   else
      flt = matrix(totPnts)+1
   endif

 # Make subplots.
  (pt1,pt2) = ucsPlot:getPlotReferences()

# Intialise phase
   ph = 0

# Accumulate scan
   for(scan = 0 to nrScans-1)

    # Set phases for this scan
      (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)

    # Send all parameter values to Spectrometer
       ucsRun:updatePPParameters(ppList,guipar)

    # Wait for the repetition time to complete
      check = ucsRun:checkTiming(guipar,scan,pcList)
      if(check == "abort")
         return(0)
      endif

    # Collect the data
      (status,data) = ucsRun:getData(nrPnts,guipar)
      if(status != "ok")
         return(0)
      endif

    # Filter the data
      data = data .* flt

    # Accumlate the data
      echoData = ucsRun:accumulate(accumulate,pAcq,echoData,data)

    # Process data
      (phasedTimeData,spectrum) = ucsRun:transformData(echoData,fAxis,guipar)

    # Plot the data 
      ucsPlot:graphTimeAndFreq(pt1,pt2,tAxis,phasedTimeData,fAxis,spectrum,scan,guipar)

    # Check if complete button pressed
      if(check == "finish")
         scan = scan+1
         exitfor()
      endif

   next(scan)

# Save the data
   ucsFiles:savePlot(pt1,:getPlotInfo("pt1"),guipar,"noReport")
   ucsFiles:savePlot(pt2,:getPlotInfo("pt2"),guipar,"simpleReport")

# Return result structure when called from backdoor
   return(null)

endproc("execpp")


########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt1","rawSpinEcho.pt1","pt2","summedSpinEcho.pt1","im1","SpinEchoEchoes.pt2"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)


###################################################################
#
# Display time domain data in the 2D plot
#
# Parameters are:
# echoData2D ... the data to display
# guipar ....... the window parameters
#
###################################################################
 
procedure(display2DData, pd,echoData2D,guipar)

   assignlist(guipar)

   tmax = acqTime*1000 

   pd->draw("false")
      pd->image(echoData2D,[0,tmax],[0,(dummyEchoes+1)*nrEchoes*echoTime])
      pd->title("SpinEcho echoes (complex)")
      pd->ylabel("echo time (\G(m)s)")
      pd->xlabel("Acquisition time (\G(m)s)")
   pd->draw("true")

endproc()

###################################################################
#
# Display the passed data points and a fitted t2 curve
#
# Parameters are:
# x ........ the time array
# y ........ the amplitude arrays
# N ........ the number of data points to plot
# guipar ... GUI parameter list
#
###################################################################
 

procedure(DisplayFit,pt2,pt3,x,y,N,guipar)

  assignlist(guipar)

   if(fitType == "nnls")
      result = :ILFit(pt2,pt3,x/1000,y,N,guipar)
   else
      result = ucsPlot:fitAndGraph(pt2,x/1000,y,N,fitType,null,
                          "Time (ms)","Echo integral (UNITS)",
                          "Echo attenuation data",
                          "Fit result: RESULT",guipar)
  endif

endproc(result)


###################################################################
#
# Display the passed data points and a fitted relaxation curve
# and relaxation spectrum
#
# Parameters are:
# x ....... the time array
# y ....... the amplitude arrays
# N ....... the number of data points to plot
# guipar ... GUI parameter list
#
###################################################################
 
procedure(ILFit,pt2,pt3,x,y,N,guipar)

   assignlist(guipar)

# Bin the data if more than 100 points
   if(N > 100)
      x_steps = 100 
     (timeDat,yData) = pseudologbin(x,y,100)
   else
     timeDat = x
     yData   = y
     x_steps = N-1
   endif

# Invert meaning of alpha and reduce range
   alpha = 10^(8-log10(alpha))

   guipar = guipar + ["exp_type = \"exp(-t/T)\"",
          "designMat = \"exp(-xData'*(1/xSpec))\"",
          "alpha = $alpha$",
          "logBin = \"true\"",
          "weightBins = \"true\"",
          "x_steps = $x_steps$"]

# Invert using Lawson and Hanson inverstion
   (specX,specY) = LHInvert(x,y,guipar)

# Get fit parameters
  (fit,chisq) = LHInvert:calcFit("exp(-t/T)",specX,specY,x,y)

# Plot original data with L&H fit
   ucsPlot:graphXYFit(pt2,x,y,fit,null,size(x),
                      "Time (ms)","Average echo amplitude (UNITS)","Echo attenuation data (with IL fit)",guipar)

   guipar = guipar + ["xMap = \"log\"",
                      "traceCol = $wvSpectrumColor$",
                      "symbolShape = \"none\""]

# Plot the spectrum
   ucsPlot:graphXY(pt3,specX,specY,null,size(specX),
                      "log_(10)(T) ms","Amplitude","Relaxation Spectrum",guipar)

endproc("")


########################################################
# Update the progress bar and experiment times
########################################################

procedure(updateProgress, scans, guipar)

# Define progress/timing expressions

   if(isvar("progressCtrl"))

      assignlist(guipar)

      if(scans == -1)
         curSNRCtrl->text("-")
      endif

      repTime = ieTime + nrEchoes*echoTime/1000

   # Define progress/timing expressions
      totTime = (nrScans+dummies)*repTime/1000
      expTime = (scans+1)*repTime/1000
      remTime = totTime - expTime
      progress = 100*expTime/totTime

   # Update controls
     ucsCtrl:updateProgress(scans+1-dummies,progress,totTime,expTime,remTime)

   endif

endproc()


########################################################
# Return expected experiment duration in seconds
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = nrScans + useStartDelay
   duration = (totScans*repTime)/1000

endproc(duration)



