#########################################################
# 
# MonitorNoise
#
# Samples noise data and calculates the rms value
#
# Copyright (c) Magritek Ltd 2025
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the KeaExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(MonitorNoise, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"MonitorNoise")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("MonitorNoise")
   else
      gExpt->addExperiment(parentPath,"MonitorNoise",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds [""] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["n1 = nrPnts",
          "totPnts = nrPnts",
          "totTime = acqTime"]
   var = [""]
   pp_list = ["n1"]
   pp_name = "MonitorNoise.p"
   phase_list = [1,1,1,1]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)


#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)

# Allocate space for output data
   sumData = cmatrix(totPnts)

# Calculate suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000   # (us)
   fAxis = ([0:1:totPnts-1]-totPnts/2)/totTime*1000 # (Hz)

# Time domain filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",tAxis/1e6)
   else
      flt = matrix(totPnts)+1
   endif

# Get plot regions
   (prt,prf) = ucsPlot:getPlotReferences()
   prt->showimag("false")
   prf->showimag("false")

# Work out frequency axis scale, label and range
   (fAxisDisp,fAxisLabel,fRange) = ucsPlot:generate1DFrequencyAxis(prf, fAxis, b1FreqCh1, 0, 0, guipar)

# Accumulate scan
   for(scan = 0 to nrScans-1)  

    # Set phases for this scan
      (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)

    # Send all parameter values to Spectrometer
       ucsRun:updatePPParameters(ppList,guipar)

    # Wait for the repetition time to complete
      check = ucsRun:checkTiming(guipar,scan,pcList)
      if(check == "abort")
         return(0)
      endif

    # Run the pulse program
      status = ucsRun:runExperiment(guipar)

    # See if stop button/escape key pressed
      if(status != "ok")
         return(0)
      endif

    # Read the data from the spectrometer
      data = ucsRun:readData(totPnts, guipar)

    # Filter the data
      data = data .* flt

    # Accumulate the data
      sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)

    # Calculate and display noise level
      if(accumulate == "yes")
         rmsNoise = sd(real(sumData))/(scan+1)
      else
         rmsNoise = sd(real(sumData))
      endif

      expNoise = sqrt(4*1.38e-23*290*bandwidth*1000*50)

      if(wvUnits == "uV")
         txtTm = "RMS noise = $rmsNoise,1.2f$ \G(m)V"
         txtFreq = "Spectrum: RMS noise = $rmsNoise,1.2f$ \G(m)V"
      elseif(wvUnits == "mV")
         txtTm = "RMS noise = $rmsNoise,1.4f$ mV"
         txtFreq = "Spectrum: RMS noise = $rmsNoise,1.2f$ mV"
      else
         txtTm = "RMS noise = $rmsNoise,1.2f$"
         txtFreq = "Spectrum: RMS noise = $rmsNoise,1.2f$"
      endif

    # Process data
      (sumData,spectrum) = ucsRun:transformData(sumData,fAxis,guipar,"fid")
        
    # Plot the data 
      prt->parent->draw("false") # Stops flashing
      ucsPlot:graphTimeAndFreq(prt,prf,tAxis,sumData,fAxisDisp,spectrum,scan,guipar,
                               txtTm,txtFreq,"","",
                               fAxisLabel,"Amplitude")
    # Plot a reference line
      if(showRef == "yes")
         :drawRef(prt,tAxis,refLevel,guipar)
      endif
      prt->parent->draw("true")

    # Check if complete button pressed
      if(check == "finish")
         scan = scan+1
         exitfor()
      endif

   next(scan)

# Save the data
   ucsFiles:savePlot(prt,:getPlotInfo("pt1"),guipar,"noReport")
   ucsFiles:savePlot(prf,:getPlotInfo("pt2"),guipar,"simpleReport")

# Add noise level result
   result = struct()
   result->tx = tAxis
   result->ty = sumData/scan
   result->noise = rmsNoise

# Return result structure when called from backdoor
   return(result)

endproc("execpp")

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt1","fid.pt1","pt2","spectrum.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)

################################################################
# Draw a noise reference line
################################################################

procedure(drawRef,pd,tm,refLevel,guipar)

   assignlist(guipar)
   if(acqTime > 5) # Switch from us to ms at 5 ms
      tfac = 0.001
   else
      tfac = 1
   endif
   N = size(tm)
   pd->draw("false")

   pd->hold("on")
   nref = matrix(N) + refLevel
   pd->plot(tm*tfac,nref,"tracecolor",wvFitCurveColor)
   pd->hold("off")
   if(wvAutoScale == "no")
      pd->zoom(0,acqTime*1000*tfac,wvTimeMin,wvTimeMax)
   endif
   pd->draw("true")

endproc()

########################################################
# Return expected experiment duration in seconds
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = nrScans + useStartDelay
   duration = (totScans*repTime)/1000

endproc(duration)

