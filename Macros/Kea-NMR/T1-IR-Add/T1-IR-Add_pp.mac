########################################################
#
# T1 inversion recovery pulse sequence with additional
# CPMG pulse sequence in which the echoes are coadded 
# to improve the signal to noise ratio.
#
# 180 - delay - 90 - delay - {180 - delay - acq}
#
# The peak amplitude is plotted as a function of
# the first delay. If manual phasing is used then the
# phase should be adjusted so that the first displayed echo
# is positive.
#
########################################################

procedure(pulse_program,dir,mode,pars)

# Expose parameters for FX3 implementation
   if(nrArgs == 3)
      assignlist(pars)
   endif

# Interface description (name, label, ctrlType, varType)
  interface = ["b1FreqCh1",       "B1 Frequency (MHz)",   "tb",     "freq";
               "90AmplitudeCh1",  "90 amplitude (dB)",    "tb",     "pulseamp";
               "180AmplitudeCh1", "180 amplitude (dB)",   "tb",     "pulseamp";
               "pulseLengthCh1",  "Pulse length (us)",    "tb",     "pulselength";
               "minDelay",        "Min. delay (ms)",      "tb",     "ldelayms";
               "maxDelay",        "Max. delay (ms)",      "tb",     "ldelayms";
               "nrSteps",         "Number of steps",      "tb",     "integer";
               "echoTime",        "Echo-time (us)",       "tb",     "sdelay";
               "nrEchoes",        "Number of echoes",     "tb",     "integer";
               "delaySpacing",    "Log. spacing",         "cb",     "lin,log";
               "ieTime",          "Inter-expt time (ms)", "tb",     "reptime"]


  tabs = ["Pulse_sequence","Acquisition","Processing_Autophase","File_Settings"]

# Relationships to determine remaining variable values
   relationships = ["n2 = 0", # x shim value
                    "n3 = 0", # y shim value
                    "n4 = 0", # z shim value
                    "n5 = 0", # o shim value
                    "a1 = 90AmplitudeCh1",
                    "a2 = 180AmplitudeCh1",
                    "d1 = pulseLengthCh1",
                    "d3 = echoTime/2-d1-pgo",
                    "d4 = echoTime/2-acqTime*500-d1/2+rxLat",
                    "d5 = echoTime-d1-pgo-d4",
                    "w1 = minDelay*1000-d1",
                    "n6 = nrPnts",
                    "totPnts = nrPnts",
                    "totTime = acqTime"]

# These parameters will be changed between experiments
   variables = ["a1","a2","w1"]

# Pulse sequence
   initpp(dir) # Reset internal parameter list

   gradon(x,n2)             # Set x shim
   gradon(y,n3)             # Set y shim
   gradon(z,n4)             # Set z shim 
   gradon(o,n5)             # Set o shim 

   cleardata(n6)
   pulse(mode,a2,p1,d1)     # 180 RF pulse
   wait(w1)                 # 180 - 90 delay
   pulse(mode,a1,p2,d1)     # 90 RF pulse
   delay(d3)                # 90 - 180 delay

   loop(l1,nrEchoes)
      pulse(mode,a2,p3,d1)  # 180 RF pulse
      delay(d4)             # 180 - acq delay
      acquire("sum",n6,d5)  # Acquire echo and wait
   endloop("l1")

   lst = endpp() # Return parameter list

# Phase cycle
  phaseList = [0,0,0,0; # +x,+x,+x,+x : 180 phase
               2,0,2,0; # -x,+x,-x,+x : 90 phase
               3,1,1,3; # -y,+y,+y,-y : 180 phase
               2,0,2,0] # -x,+x,-x,+x : Acquire phase

endproc(lst,tabs,interface,relationships,variables,null,phaseList)

#####################################################
# Assign those parameters which should take their 
# values from the factory defaults when making a 
# new experiment
#####################################################

procedure(getFactoryBasedParameters, par)

   specPar = KeaParameterUpdater:readSpecPar()
   if(specPar == null)
      return(null)
   endif
   assignlist(specPar)

   par = ["rxGain           = $rxOptGaindB$",
          "pulseLengthCh1   = $pulseLengthCh1*2$",
          "90AmplitudeCh1   = $pulseAmplitudeCh1$",
          "180AmplitudeCh1  = $pulseAmplitudeCh1$",
          "b1FreqCh1        = $frequencyCh1$"]

endproc(par)