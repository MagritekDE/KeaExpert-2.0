#########################################################
# 
# T1-IR-Add
#
# T1 inversion recovery pulse sequence with additional
# CPMG pulse sequence in which the echoes are coadded 
# to improve the signal to noise ratio.
#
# 180 - delay - 90 - delay - {180 - delay - acq}
#
# The peak amplitude is plotted as a function of
# the first delay. If manual phasing is used then the
# phase should be adjusted so that the first displayed echo
# is positive.
#
# Copyright (c) Magritek Ltd 2025
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the KeaExpert 
# interface. It will add the experiment to the parameter
# list or with the shift key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(T1-IR-Add, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"T1-IR-Add")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("T1-IR-Add")
   else
      gExpt->addExperiment(parentPath,"T1-IR-Add",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds ["a1","a2","w1"] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["n2 = 0",
          "n3 = 0",
          "n4 = 0",
          "n5 = 0",
          "a1 = 90AmplitudeCh1",
          "a2 = 180AmplitudeCh1",
          "d1 = pulseLengthCh1",
          "d3 = echoTime/2-d1-pgo",
          "d4 = echoTime/2-acqTime*500-d1/2+rxLat",
          "d5 = echoTime-d1-pgo-d4",
          "w1 = minDelay*1000-d1",
          "n6 = nrPnts",
          "totPnts = nrPnts",
          "totTime = acqTime"]
   var = ["a1","a2","w1"]
   pp_list = ["n2","n3","n4","n5","n6","a2","p1","d1","w1","a1","p2","d3","nrEchoes","l1","p3","d4","d5"]
   pp_name = "T1-IR-Add.p"
   phase_list = [0,0,0,0;2,0,2,0;3,1,1,3;2,0,2,0]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)

#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)

# Check RF duty cycle
   if(ucsRun:highDutyCycle((nrEchoes+2)*d1,(minDelay+echoTime*(nrEchoes+0.5))*1000,guipar))
      return(0)
   endif

# Do some sanity checks
   if(d3 <= 0 | d4 <= 0 | d5 <= 0 | w1 <= 0)
      message("Error","Pulse sequence timing error!\rIncrease minimum delay.","error")
      return(0)
   endif

# Calculate a suitable time axis
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000
   fAxis = ([0:1:totPnts-1]-totPnts/2)/totTime

# Filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTEcho",totPnts)
   else
      flt = matrix(totPnts)+1
   endif

# Make subplots.
   (pt1,pt2,pt3) = ucsPlot:getPlotReferences()

# Allocate memory for outputs
   echoDelay  = matrix(nrSteps)
   echoInt    = matrix(nrSteps)
   echoError  = matrix(nrSteps)

# Make the delay array
   if(delaySpacing == "log")
      dArray = ucsRun:logAxis(minDelay,maxDelay,nrSteps)*1000
   else
      dArray = linvec(minDelay,maxDelay,nrSteps)*1000
   endif
   preDelayArray = [minDelay,maxDelay*3,maxDelay*3]*1000
   totDelayArray = join(preDelayArray,dArray) # Delays in us

# Work out extra delays
   extraDelays = d1+d3+nrEchoes*echoTime

   pc = 1 # Initialise phase correction

# First time we put the ieTime at the start
   tEndPS = time()

# Loop over the delay times
   for(d = -3 to nrSteps-1)

      if(d == -3) # Get noise estimate
         ampdB1 = -85
         ampdB2 = -85
         dly = minDelay
      elseif(d == -2 | d == -1) # Get dummy scan/long time scan
         ampdB1 = a1
         ampdB2 = a2
         dly = round(dArray[nrSteps-1]*3)-d1-pgo
         tm = 3*dArray[nrSteps-1]/1000
      else # Normal experiment
         ampdB1 = a1
         ampdB2 = a2
         dly = round(dArray[d])-d1-pgo
         tm = dArray[d]/1000
      endif
    # Update the pulse program amplitudes and delay
      ppList = ucsRun:setPPAmplitude(ppList,varIndex[0],ampdB1)
      ppList = ucsRun:setPPAmplitude(ppList,varIndex[1],ampdB2)
      ppList = ucsRun:setPPLongDelay(ppList,varIndex[2],dly)

    # Initialise FID array
      sumData = cmatrix(totPnts)  

   # Accumulate scan
      for(scan = 0 to nrScans-1)

       # Wait for the inter-experiment time to complete
         check = ucsRun:checkTiming(guipar,scan,pcList,tEndPS)
         if(check == "abort")
            return(0)
         endif
   
       # Set phases for this scan
         (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)

       # Send all parameter values to spectrometer (DSP)/generate event table (FX3)
         ucsRun:updatePPParameters(ppList,guipar)
   
       # Run the p.p. and collect the data
         (status,data) = ucsRun:getData(totPnts,guipar)
         if(status != "ok")
            return(0)
         endif

       # Record when the ps finishes
         tEndPS = time()

       # Filter the data
         data = data .* flt
   
       # Accumlate the data
         sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)
   
       # Process the data
        (sumData,spectrum) = ucsRun:transformData(sumData,fAxis,guipar,"echo")

       # Graph the data
         if(d == -3)
            titleTxt = "Noise scan"
         elseif(d == -2)
            titleTxt = "Dummy scan : Delay = $tm,2.2f$ ms"
         elseif(d == -1)
            titleTxt = "Phasing scan : Delay = $tm,2.2f$ ms"
         else
            titleTxt = "Echo sum : Delay = $tm,2.2f$ ms"
         endif
         ucsPlot:graphTimeAndFreq(pt1,pt2,tAxis,sumData*pc,fAxis,spectrum*pc,scan,guipar,titleTxt)

         if(check == "finish")
            scan = scan+1
            exitfor()
         endif

      next(scan)

    # Integrate the time domain data
      if(d == -3) # Get noise estimate
         try
            error  = sd(real(sumData/nrScans))*sqrt(nrPnts)
         catch
            message("Error","Integration width or frequency resolution is too small.","error")
            return(0)
         endtry

      elseif(d == -1) # Get maximum echo amplitude and update phase
         if(autoPhase == "yes")
            ph = ucsRun:autoPhaseFreq(sumData)-180
            try
               n = findobj(0,"name","rxPhase")
               newPhase = (eval(getpar(0,n,"text"))-ph)%360
               setpar(0,n,"text",newPhase)  
            catch; endtry;
            pc = exp(i*ph/180*pi)
         else
            pc = 1
         endif
         maxEcho = sumData

      elseif(d >= 0)     
         echoInt[d]  = sum(real(pc*(sumData - maxEcho))/nrScans)/nrPnts # Average of difference between collected data and long time measuremet
         echoDelay[d] = dly/1000
         echoError[d]  = error*2/sqrt(nrPnts) # Doubled due to subtraction and reduced due to signal averaging 
      # Plot the integrals
         ucsPlot:fitAndGraph(pt3,echoDelay,echoInt,d+1,"T2",echoError,
                            "180-90 delay (ms)","Average echo amplitude",
                            "T_(1) attenuation data",
                            "T_(1) = RESULT ms",guipar)
      endif

      if(check == "finish")
         exitfor()
      endif

   next(dly)

# Save data
   ucsFiles:savePlot(pt3,:getPlotInfo("pt3"),guipar,"simpleReport")

# Return result structure when called from backdoor
   result = struct()
   result->delay = echoDelay
   result->int = echoInt

   return(result)

endproc("execpp") # Don't remove argument


########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt3","T1IRAdd.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)

########################################################
# Return expected experiment duration
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)

   if(delaySpacing == "log")
      dArray = logspace(minDelay,maxDelay,nrSteps)*1000
   else
      dArray = linspace(minDelay,maxDelay,nrSteps)*1000
   endif

   totDelayTime = sum(dArray)+minDelay*1000 # Include dummy
   nrDummys = 1
   psTime = GetPulseProgramDuration("T1iet",1,guipar)*1000
   psTime = psTime - minDelay*10000 # Base ps duration
   psTime = psTime + nrPnts*10 # Data collection time estimate
   totScans = (nrSteps+nrDummys)*nrScans
   duration = (totScans*(psTime+ieTime*1000) + nrScans*totDelayTime)/1e6

endproc(duration)

