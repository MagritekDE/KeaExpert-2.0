#########################################################
# 
# Find90
#  
# A pulse sequence suitable for performing a
# single scan 1H nutation curve
#
# (pulse - delay - acq)n
#
# Initial version
#
# Bulat Gizatullin
# May 2025
#
# Copyright (c) Magritek Ltd 2025
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the KeaExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(Find90, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"Find90")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("Find90")
   else
      gExpt->addExperiment(parentPath,"Find90",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds [""] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["nDataPnts  = nrPnts",
          "a90Amp     = 90Amplitude",
          "d90Dur     = pulseLength",
          "nEcho      = nrEchoes",
          "dAcqDelay  = 10",
          "dAcq       = dwellTime*(nrPnts+20)",
          "totPnts    = nEcho",
          "totTime    = acqTime"]
   var = [""]
   pp_list = ["nEcho","l1","a90Amp","p1","d90Dur","dAcqDelay","nrPnts","dAcq"]
   pp_name = "Find90.p"
   phase_list = [0,1,2,3;0,1,2,3]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)

#########################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
# March 2021 CDE
#########################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

   assignlist(guipar)

# Calculate total time for x axis
   totalTime = [0:1:nrEchoes-1]*pulseLength
   sumData = cmatrix(totPnts)
   newphase=0

   prt = ucsPlot:getPlotReferences()

   # Accumulate scan
   for(scan=0 to nrScans-1)

    # Set phases for this scan
      (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)
   
    # Send all parameter values to spectrometer
       ucsRun:updatePPParameters(ppList,guipar)  
   
    # Wait for repetition time and check for abort
      check = ucsRun:checkTiming(guipar,scan,pcList)
      if(check == "abort")
         return(0)
      endif

    # Run the pulse program and collect the data
      (status,data) = ucsRun:getData(totPnts,guipar)

    # See if the abort button has been pressed
      if(status == "abort")
         return(0)
      endif
  
      # Accumlate the data
      sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)

      sumData = shift(sumData,1)

      if(accumulate=="yes")
         sf = 1/(scan+1)
      else
         sf = 1
      endif

      if(autoPhase=="yes")
         ph = (180/pi)*:findPhase(totalTime,sf*sumData)
         newphase = -ph+rxPhase
         newphase= 0.1*(10*newphase%3600)
      else
         ph = 0
      endif

      sumData = sumData*exp(-i*ph*pi/180)

# figure out 90- and 1800- degree pulse using zero crossing
      (val,pos) = max(mag(sf*sumData))
      P90 = totalTime[pos]

# plot the nutation curve
      prt->draw("false")
      prt->plot(totalTime,sf*sumData)      
      prt->title("text","Nutation 1H (P90 = $P90$ \G(m)s)")
      prt->xlabel("text","Time (us)")
      prt->ylabel("text","Amplitude")
      prt->draw("true")
      prt->rmlines()
      prt->addline(P90,-inf,P90,inf,[0,0,128],1, "dashes")
#      prt->trace(0)->symbolshape("circle")


    # Check if complete button pressed
      if(status == "finish")
         scan = scan+1
         exitfor()
      endif

   next(scan)

# Update the common parameters locally and in the file
   if(90Amplitude+6 <= 0)
      gData->commonPar->90AmplitudeCh1 = 90Amplitude
      gData->commonPar->180AmplitudeCh1 = 90Amplitude+6
      gData->commonPar->pulseLengthCh1 = P90
   else
      gData->commonPar->90AmplitudeCh1 = 90Amplitude-6
      gData->commonPar->180AmplitudeCh1 = 90Amplitude
      gData->commonPar->pulseLengthCh1 = P90*2
   endif
   par = struct(ucsFiles:loadCommonPar())
   par->pulseLengthCh1 = gData->commonPar->pulseLengthCh1
   par->90AmplitudeCh1 = gData->commonPar->90AmplitudeCh1
   par->180AmplitudeCh1 = gData->commonPar->180AmplitudeCh1
   ucsFiles:saveCommonPar(par)

# Save the nutation curve
   ucsFiles:savePlot(prt,:getPlotInfo("pt1"),guipar,"noReport")

   result = struct()
   result->tNut = totalTime
   result->aNut = sf*sumData
   result->P90 = P90
   return(result)

endproc("execpp") # Don't remove argument


########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################
procedure(getPlotInfo,plotRegion)

   info = ["pt1","fid.pt1","pt2","spectrum.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)

########################################################
# Return expected experiment duration in seconds
########################################################
procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = nrScans + useStartDelay
   duration = (totScans*repTime)/1000

endproc(duration)


#######################################################
procedure(findRoot,x1,y1,x2,y2,y0)

     x0 = x1 + (y0-y1)*(x2-x1)/(y2-y1)

endproc(x0)


#######################################################
procedure(max2, x1,y1,x2,y2,x3,y3)

   xmax=0.5*( y1*(x3*x3-x2*x2)+y2*(x1*x1-x3*x3)+y3*(x2*x2-x1*x1) )/(y1*(x3-x2)+y2*(x1-x3)+y3*(x2-x1) )

endproc(xmax)


#########################################
# Find the phase of nutation curve
########################################
procedure(findPhase,nutTime,nutAmpComplex)

    nrIncr  = size(nutTime)
    nutAmp  = mag(nutAmpComplex)

    slopeOld = 1
    for(k = 1 to nrIncr-1)
   
      if(nutAmp[k-1] <= nutAmp[k])  # growing
         slope = 1
      else                          # decreasing
         slope = -1
      endif
   
      if(slopeOld != slope)    # found a maximum 
         t_max = :max2(nutTime[k-2],nutAmp[k-2],nutTime[k-1],nutAmp[k-1],nutTime[k-0],nutAmp[k-0])
         ph = phase(nutAmpComplex[k-1])
#pr k-1,ph
         return(ph)
      endif
   
     slopeOld = slope

  next(k)

endproc(0)
