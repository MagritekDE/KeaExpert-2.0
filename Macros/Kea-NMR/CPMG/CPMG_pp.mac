########################################################
#
# CPMG pulse sequence with dummy pulses
# (following a dummy 180-pulse data is not collected)
#
# 90 - delay - {180 - delay - acq - {180 - delay}}
#
########################################################

procedure(pulse_program,dir,mode,pars)

# Expose parameters for FX3 implementation
   if(nrArgs == 3)
      assignlist(pars)
   endif

# Interface description (name, label, ctrlType, varType)
   interface = ["b1FreqCh1",       "B1 Frequency (MHz)",    "tb",  "freq";
                "90AmplitudeCh1",  "90 amplitude (dB)",     "tb",  "float,[-85,-6]";
                "180AmplitudeCh1", "180 amplitude (dB)",    "tb",  "pulseamp";
                "pulseLengthCh1",  "Pulse length (us)",     "tb",  "float,[1,500]";
                "echoTime",        "Echotime (us)",         "tb",  "sdelay";
                "nrEchoes",        "Number of echoes",      "tb",  "integer,[1,8192]";
                "echoShift",       "Echo shift (us)",       "tb",  "float,[-20,20]";
                "dummyEchoes",     "Dummy echoes",          "tb",  "integer,[0,100]";
                "dummies",         "Dummy scans",           "tb",  "integer,[0,20]";
                "repTime",         "Repetition time (ms)",  "tb",  "float,[20,1e8]"]

   groups = ["Pulse_sequence","Acquisition","Laplace_CPMG","File_Settings"]

# Relationships between pulse-sequence and GUI parameters
   relationships = ["nxShim = 0", #xcal*xshim/1000", # x shim value
                    "nyShim = 0", #ycal*yshim/1000", # y shim value
                    "nzShim = 0", #zcal*zshim/1000", # z shim value
                    "noShim = 0", #ocal*oshim/1000", # o shim value
                    "a90            = 90AmplitudeCh1",
                    "a180           = 180AmplitudeCh1",
                    "dRF            = pulseLengthCh1",
                    "d90_180        = echoTime/2-dRF/2-pgo-2",
                    "d180_acq       = echoTime/2-acqTime*500-dRF/2+rxLat-1+echoShift",
                    "dAcq           = echoTime-dRF-pgo-d180_acq-2",
                    "dAcq2          = dAcq+1",
                    "dDummy         = echoTime-dRF-pgo-2",
                    "nEchoes        = nrEchoes",
                    "nPnts          = nrPnts",
                    "nZeroDummy     = (dummyEchoes==0)",
                    "nOneDummy      = (dummyEchoes==1)",
                    "nManyDummies   = (dummyEchoes>1)",
                    "nDummies       = dummyEchoes-1",
                    "totPnts        = nrPnts*nrEchoes",
                    "totTime        = nrEchoes*echoTime*(dummyEchoes+1)"]

# These parameters will be changed between experiments
   variables = [""]

# Pulse sequence
   initpp(dir) # Reset internal parameter list

#  gradon("x",nxShim)                    # Set x shim
#  gradon("y",nyShim)                    # Set y shim
#  gradon("z",nzShim)                    # Set z shim 
#  gradon("o",noShim)                    # Set o shim 

# Three options are required to get the timing exact in all cases
# because the loop and skip statments all require 1 us.
  iftrue("s1",nZeroDummy)             # No dummy loop if dummyEchoes == 0
      pulse(mode,a90,p1,dRF)               # 90 RF pulse
      delay(d90_180)                       # 90 - 180 delay
      loop("l1",nEchoes)                   # CPMG echo loop
         pulse(mode,a180,p2,dRF)              # 180 RF pulse
         delay(d180_acq)                      # 180 - acq delay
         acquire("append",nPnts,dAcq)         # Acquire echo and wait
      endloop("l1")                        # End CPMG loop
   endiftrue("s1")

  iftrue("s2",nOneDummy)              # Add dummy loop if dummyEchoes == 1
      pulse(mode,a90,p1,dRF)               # 90 RF pulse
      delay(d90_180)                       # 90 - 180 delay
      loop("l2",nEchoes)                   # CPMG echo loop
         pulse(mode,a180,p2,dRF)               # 180 RF pulse
         delay(d180_acq)                       # 180 - acq delay
         acquire("append",nPnts,dAcq2)         # Acquire echo and wait
         pulse(mode,a180,p2,dRF)               # 180 internal pulse
         delay(dDummy)                         # Dummy echo time delay
      endloop("l2")                        # End CPMG loop
   endiftrue("s2")

  iftrue("s3",nManyDummies)            # Add dummy loop if dummyEchoes > 1
      pulse(mode,a90,p1,dRF)                  # 90 RF pulse
      delay(d90_180)                       # 90 - 180 delay
      loop("l3",nEchoes)                   # CPMG echo loop
         pulse(mode,a180,p2,dRF)              # 180 RF pulse
         delay(d180_acq)                      # 180 - acq delay
         acquire("append",nPnts,dAcq)         # Acquire echo and wait
         loop("l4",nDummies)                  # Dummy echo loop
            pulse(mode,a180,p2,dRF)               # 180 internal pulse
            delay(dDummy)                         # Dummy echo time delay
         endloop("l4")                        # End dummy loop
         pulse(mode,a180,p2,dRF)              # 180 internal pulse
         delay(dDummy)                        # Dummy echo time delay
      endloop("l3")                        # End CPMG loop
   endiftrue("s3")

#  gradoff("x")                    # Set x shim
#  gradoff("y")                    # Set y shim
#  gradoff("z")                    # Set z shim 
#  gradoff("o")                    # Set o shim 

   lst = endpp(0) # Return parameter list

# Phase cycle

   phaseList = [2,0,2,0; # -x,x,-x,x : 90 phase
                3,1,1,3; # -y,y,y,-y : 180 phase
                2,0,2,0] # -x,x,-x,x : Acquire phase

endproc(lst,groups,interface,relationships,variables,0,phaseList)


#####################################################
# Assign those parameters which should take their 
# values from the factory defaults when making a 
# new experiment
#####################################################

procedure(getFactoryBasedParameters, par)

   specPar = KeaParameterUpdater:readSpecPar()
   if(specPar == null)
      return(null)
   endif
   assignlist(specPar)

   par = ["rxGain          = $rxOptGaindB$",
          "pulseLengthCh1  = $pulseLengthCh1*2$",
          "90AmplitudeCh1  = $pulseAmplitudeCh1$-6",
          "180AmplitudeCh1 = $pulseAmplitudeCh1$",
          "b1FreqCh1       = $frequencyCh1$"]

endproc(par)
