#########################################################
# 
# 1Pulse
#
# A pulse sequence suitable for performing a
# pulse and collect experiment.
#
# pulse - delay - acq
#
# Copyright (c) Magritek Ltd 2025
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the KeaExpert 
# interface. It will add the experiment to the parameter
# list or with the shift key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(1Pulse, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"1Pulse")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("1Pulse")
   else
      gExpt->addExperiment(parentPath,"1Pulse",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds [""] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["nDataPnts = nrPnts",
          "a90Amp    = 90AmplitudeCh1",
          "d90Dur    = pulseLengthCh1",
          "dAcqDelay = acqDelay",
          "totPnts   = nrPnts",
          "totTime   = acqTime"]
   var = [""]
   pp_list = ["a90Amp","p1","d90Dur","dAcqDelay","nDataPnts"]
   pp_name = "1Pulse.p"
   phase_list = [0,1,2,3;0,1,2,3]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)

#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list (DSP only)
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)

# Allocate space for output data
   sumData = cmatrix(totPnts)

# Calculate suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000   # (us)
   fAxis = ([0:1:totPnts-1]-totPnts/2)/totTime*1000 # (Hz)

# Time domain filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",tAxis/1e6)
   else
      flt = matrix(totPnts)+1
   endif

# Get plot regions
   (pt1,pt2) = ucsPlot:getPlotReferences()
   pt1->showimag("false")
   pt2->showimag("false")

# Accumulate scans
   for(scan = 0 to nrScans-1)

    # Set phases for this scan
      (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)

    # Send all parameter values to spectrometer (DSP)/generate event table (FX3)
       ucsRun:updatePPParameters(ppList,guipar)

    # Wait for the repetition time to complete
      check = ucsRun:checkTiming(guipar,scan,pcList)
      if(check == "abort")
         return(0)
      endif

    # Run the pulse program
      status = ucsRun:runExperiment(guipar)

    # See if stop button/escape key pressed
      if(status != "ok")
         return(0)
      endif

    # Read the data from the spectrometer
      data = ucsRun:readData(totPnts, guipar)

    # Apodize the data
      data = data .* flt

    # Accumulate the data
      sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)

    # FT the data
      (phasedTimeData,spectrum) = ucsRun:transformData(sumData,fAxis,guipar)

    # Plot the FID and spectrum 
      ucsPlot:graphTimeAndFreq(pt1,pt2,tAxis,phasedTimeData,fAxis,spectrum,scan,guipar)

    # Check if complete button pressed
      if(check == "finish")
         scan = scan+1
         exitfor()
      endif

   next(scan)

# Save the data
   ucsFiles:savePlot(pt1,:getPlotInfo("pt1"),guipar,"noReport")
   ucsFiles:savePlot(pt2,:getPlotInfo("pt2"),guipar,"simpleReport")

# Pack the data into a structure
   result = struct()
   result->tx = tAxis
   result->ty = sumData/scan
   result->fx = fAxis
   result->fy = spectrum/scan

# Return result
   return(result)

endproc("execpp") # Don't remove argument

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt1","fid.pt1","pt2","spectrum.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)

########################################################
# Return expected experiment duration in seconds
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)

   totScans = nrScans + useStartDelay
   duration = (totScans*repTime)/1000

endproc(duration)
