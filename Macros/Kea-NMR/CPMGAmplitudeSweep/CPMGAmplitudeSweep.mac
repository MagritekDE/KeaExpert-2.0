#########################################################
# 
# CPMGAmplitudeSweep
#
# CPMG pulse sequence in which each echo is summed to 
# return a single complex number per echo.
# The amplitude of the RF pulses is then stepped to find
# the optimal 90/180 combination
#
# 90 - delay - {180 - delay - acq}
#
# Copyright (c) Magritek Ltd 2025
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the KeaExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(CPMGAmplitudeSweep, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"CPMGAmplitudeSweep")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("CPMGAmplitudeSweep")
   else
      gExpt->addExperiment(parentPath,"CPMGAmplitudeSweep",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds ["a90","a180"] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["nxShim = 0",
          "nyShim = 0",
          "nzShim = 0",
          "noShim = 0",
          "a90      = minAmp",
          "a180     = minAmp+6",
          "dRF      = pulseLengthCh1",
          "d90_180  = echoTime/2-dRF/2-pgo-2",
          "d180_acq = echoTime/2-acqTime*500-dRF/2+rxLat-1+echoShift",
          "dAcq     = echoTime-dRF-pgo-d180_acq-2",
          "nEchoes  = nrEchoes",
          "nPnts    = nrPnts",
          "totPnts  = nrEchoes",
          "totTime  = echoTime*nrEchoes"]
   var = ["a90","a180"]
   pp_list = ["nxShim","nyShim","nzShim","noShim","a90","p1","dRF","d90_180","nEchoes","l1","a180","p2","d180_acq","nPnts","dAcq"]
   pp_name = "CPMGAmplitudeSweep.p"
   phase_list = [2,0,2,0;3,1,1,3;2,0,2,0]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)

#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)

# Check for invalid delays
   if(d90_180 < 1 | d180_acq < 1 | dAcq < 1)
      message("Error","Pulse sequence timing error!\rReduce acquisition time or increase echotime.","error")
      return(0)
   endif

# Make sure we can collect all data without modifying echotime
   if(dAcq-ucsRun:getAcqTime(guipar) <= 0)
      message("Error","Pulse sequence timing error!\rReduce acquisition time or increase echotime.","error")
      return(0)
   endif

# Check amplitude range
   if((minAmp + ampStep*nrSteps + 6) > 0)
       message("Error","Pulse amplitude error!\rReduce 90 amplitude range, must be <= -6 dB.","error")
      return(0)
   endif  

# # Check RF duty cycle
#   if(ucsRun:highDutyCycle(dRF*nEchoes,nEchoes*echoTime,guipar))
#      return(0)
#   endif

# Allocate data for outputs
   amplitudeAxis = linspace(minAmp, minAmp + (nrSteps-1)*ampStep, nrSteps)
   specInt = matrix(nrSteps)

# Calculate a suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime + echoTime # us
   fAxis = ([0:1:totPnts-1]-totPnts/2)/totTime*1e6 # Hz

# Make plot regions.
   (pt1,pt2,pt3) = ucsPlot:getPlotReferences()

# Step over amplitudes
   for(stp = 0 to nrSteps-1)

     # Update the pulse amplitude
      a90    = minAmp + stp*ampStep
      a180   = a90+6
      ppList = ucsRun:setPPAmplitude(ppList,varIndex[0],a90)
      ppList = ucsRun:setPPAmplitude(ppList,varIndex[1],a180)

      # Initialize the CPMG data array
      sumData = cmatrix(totPnts)

     # Accumulate scans using these parameters
      for(scan = 0 to nrScans-1)
   
       # Set phases for this scan
         (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)
   
       # Send all parameter values to Spectrometer
          ucsRun:updatePPParameters(ppList,guipar)
   
       # Wait for the repetition time to complete
         check = ucsRun:checkTiming(guipar,scan,pcList)
         if(check == "abort")
            return(0)
         endif
   
       # Collect the data
         (status,data) = ucsRun:getData(totPnts,guipar)
         if(status != "ok")
            return(0)
         endif
   
       # Accumlate the data
         sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)

       # Autophase
         if(autoPhase == "yes")
            (ph,sumDataAP) = ucsRun:autoPhase(sumData/nrPnts,"minsd")
         else
            sumDataAP = sumData/nrPnts
         endif

       # Process the data
        (phasedTimeData,spectrum) = ucsRun:transformData(sumDataAP,fAxis,guipar,"fid",1,1)

       # Display the data
         ucsPlot:graphTimeAndFreq(pt1,pt2,tAxis,sumDataAP,fAxis,spectrum,scan,guipar,
                                  "CPMGInt Scan: $scan+1$/$nrScans$, Pulse-amp: $a90$ dB", "CPMG Spectrum",
                                  "Time (ms)", "CPMGInt amplitude (\G(m)V)","Frequency (Hz)", "Amplitude (\G(m)V/Hz)")
                                  

       # Check if complete button pressed
         if(check == "finish")
            scan = scan+1
            exitfor()
         endif
   
      next(scan)

     # Integrate the spectrum to get the initial CPMG amplitude
      specInt[stp]  = 2*integvector(fAxis,real(spectrum)/nrScans,-intWidth/2,intWidth/2)

     # Plot the integrals
      ucsPlot:graphXY(pt3,amplitudeAxis,specInt,null,stp+1,
                     "Pulse Amplitude (dB)","Peak Integral",
                     "Pulse Amplitude Analysis",guipar)

     # Check if complete button pressed
      if(check == "finish")
         scan = scan+1
         exitfor()
      endif

   next(stp)


# Save the data
  ucsFiles:savePlot(pt3,:getPlotInfo("pt3"),guipar,"simpleReport")

# Return result structure when called from backdoor
   result = struct()
   result->x = amplitudeAxis
   result->y = specInt

   return(result)

endproc("execpp") # Don't remove argument

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt3","CPMGDurSweep.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)


########################################################
# Return expected experiment duration in seconds
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = (nrScans + useStartDelay)*nrSteps
   duration = (totScans*repTime)/1000

endproc(duration)

