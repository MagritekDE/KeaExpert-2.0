#########################################################
# 
# T1T2
#                T1T2_pp.mac
#
# T1-T2 correlation experiment for the RCA
#
# 180 - delay - 90 - delay - {180 - delay - acqu - {180 - delay} }
#
# This pulse sequence will implement an inversion
# recovery experiment to encode for T1 followed by 
# a CPMG echo train to measure T2. The CPMG train
# includes dummy pulses to allow for long acquisition
# times while still using small echo times.
#
# a1 ... amplitude of 180 pulse
# a2 ... amplitude of 90 pulse
# p1 ... phase of first 180 pulse
# p2 ... phase of 90 pulse
# p3 ... phase of CPMG 180 pulses
# d1 ... width of pulses
# d2 ... delay between 90 and CPMG 180
# d3 ... delay between CPMG 180 and acquisition
# d4 ... delay between acquisition start and next CPMG 180 
# d5 ... delay between CPMG 180 dummy pulses
# n1 ... number of echos to collect
# n2 ... number of data points to collect per echo
# n3 ... number of 180 dummy pulses per echo
#
# Copyright (c) Magritek Ltd 2025
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the KeaExpert 
# interface. It will add the experiment to the parameter
# list or with the shift key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(T1T2, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"T1T2")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("T1T2")
   else
      gExpt->addExperiment(parentPath,"T1T2",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds ["w180_90"] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["a90 = 90AmplitudeCh1",
          "a180 = 180AmplitudeCh1",
          "dRF = pulseLengthCh1",
          "w180_90 = minTau*1000-dRF-pgo-0.5",
          "d90_180 = echoTime/2-dRF-pgo-0.5",
          "d180_acq = echoTime/2-acqTime*500-dRF/2+rxLat-1+echoShift",
          "dAcq = echoTime-dRF-pgo-d180_acq-1",
          "dDummy = echoTime-dRF-pgo",
          "nEchoes = nrEchoes",
          "nPnts = nrPnts",
          "nDummy = dummyEchoes",
          "nxShim = 0",
          "nyShim = 0",
          "nzShim = 0",
          "noShim = 0",
          "totPnts = nrEchoes",
          "totTime = nrEchoes*echoTime*(dummyEchoes+1)"]
   var = ["w180_90"]
   pp_list = ["nxShim","nyShim","nzShim","noShim","nEchoes","a180","p1","dRF","w180_90","a90","p2","d90_180","l1","p3","d180_acq","nPnts","dAcq","nDummy","l2","dDummy"]
   pp_name = "T1T2.p"
   phase_list = [0,2,0,2;0,0,2,2;1,1,1,1;0,0,2,2]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)


#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)

   guipar = guipar + "timeMag = \"no\""

# Do some safety checks
   if(d90_180 < 1 | d180_acq < 1 | dAcq < 1)
      message("Error","Pulse sequence timing error!\rReduce acquisition time or increase echotime.","error")
      return(0)
   endif

   if(dAcq-ucsRun:getAcqTime(guipar) <= 0)
      message("Error","Pulse sequence timing error!\rReduce acquisition time or increase echotime.","error")
      return(0)
   endif

# Calculate suitable time axes
   totalTime = ([0:1:totPnts-1]/totPnts)*totTime + echoTime

# Storage for each tau value
   data2d = cmatrix(totPnts,tauSteps)
   endData = cmatrix(totPnts)

# Make 1 subplot for both 1D and 2D
   (pt1,im1) = ucsPlot:getPlotReferences()

# Make the delay array
   if(delaySpacing == "log")
      dArray = ucsRun:logAxis(minTau,maxTau,tauSteps)*1000
   else
      dArray = linvec(minTau,maxTau,tauSteps)*1000
   endif

# Add setting up delays
   preDelayArray = [maxTau*3,minTau]*1000
   totDelayArray = join(preDelayArray,dArray) # Delays in us

# Work out extra delays
   extraDelays = nEchoes*echoTime + echoTime/2 + dRF+pgo

# Intialise the receiver phase
   ph = 0

# First time we put the ieTime at the start
   tEndPS = time()

# Loop over the T1 delay values
   for(d = -2 to tauSteps-1)

   # Set inversion recovery delay
      if(d == -2)
         dly = dArray[tauSteps-1]*3 # Reference delay
      elseif(d == -1)
         dly = dArray[0]
      else
         dly = dArray[d]
      endif

      ppList = ucsRun:setPPLongDelay(ppList,varIndex[0],dly-dRF-pgo-0.5)

   # Storage for accumulated data
      sumData = cmatrix(totPnts)

   # Accumulate scan
      for(scan = 0 to nrScans-1)
   
       # Wait for the inter-experiment time to complete
         check = ucsRun:checkTiming(guipar,scan,pcList,tEndPS)
         if(check == "abort")
            return(0)
         endif  
   
       # Set phases for this scan
         (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)
   
       # Send phase parameters to DSP
         ucsRun:updatePPParameters(ppList,guipar)
   
       # Collect the data
         (status,data) = ucsRun:getData(totPnts,guipar)
         if(status != "ok")
            return(0)
         endif

       # Record when the ps finishes
         tEndPS = time()

       # Accumlate the data
         sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)
   
         if(autoPhase == "yes" & d == -2)
            ph = ucsRun:autoPhase(sumData,phaseMethod)
         endif

         sumDataAP = sumData*exp(i*ph/180*pi)

       # Graph the data
         if(d == -2)
            timeTxt = "CPMG echo amplitude: reference delay = $dly/1000,2.2f$ ms SCANS"
         elseif(d == -1)
            timeTxt = "CPMG echo amplitude: dummy scan: delay = $dly/1000,2.2f$ ms SCANS"
         else
            timeTxt = "CPMG echo amplitude: \G(t) = $dly/1000,2.2f$ ms SCANS"
         endif

         ucsPlot:graphTime(pt1,totalTime/1000,sumDataAP/nrPnts,scan,guipar,timeTxt,"Echo time (ms)","Average echo amplitude (\G(m)V)")  

         if(check == "finish")
            scan = scan+1
            exitfor()
         endif
   
      next(scan)

      if(d == -2)
         endData = sumDataAP
      elseif(d >= 0)
         data2d[~,d] = endData - sumDataAP       
      endif

   # Display the 2D data
      im1->draw("false")
      im1->axes->xmapping("lin")
      if(delaySpacing == "log")
         im1->image(data2d,[totalTime[0],totalTime[-1]]/1000,[dArray[0],dArray[-1]]/1000)
         im1->ylabel("IR-delay (ms) - log mode")
         im1->axes->ymapping("log")
      else
         im1->image(data2d,[totalTime[0],totalTime[-1]]/1000,[dArray[0],dArray[-1]]/1000)
         im1->ylabel("IR-delay (ms)")
         im1->axes->ymapping("lin")
      endif
      im1->title("T_(1)-T_(2) Correlation Data")
      im1->xlabel("Echo time (ms)")
      im1->draw("true")

      if(check == "finish")
         exitfor()
      endif

   next(d)

# Save the data
   ucsFiles:saveImage(im1,:getPlotInfo("im1"),guipar,"simpleReport")

# Return data
   result = struct()
   result->xaxis = linvec(totalTime[0]/1e3,totalTime[-1]/1e3,nrEchoes)
   result->yaxis = dArray/1e6
   result->T1T2corr = data2d

   return(result)

endproc("execpp")

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["im1","T1T2.pt2",
           "im2","T1IRT2Spectrum.pt2"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)

