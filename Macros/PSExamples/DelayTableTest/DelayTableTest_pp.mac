############################################################
#  
# Generates a table controlled short delay between a
# series of RF pulses. (FX3 only)
# The 'report' command was used to determine the various
# event-table delays in the loop and so correct the 
# delay-table entries get accurate timing.
#
############################################################

procedure(pulse_program,dir,mode,pars)

# Expose parameters for FX3 implementation
   if(nrArgs == 3)
      assignlist(pars)
   endif

# Interface description (name, label, ctrl, vartype)
  interface = ["nucleus",         "Nucleus",                   "tb",  "readonly_string";
               "b1Freq1H",        "1H frequency (MHz)",        "tb",  "freq";
               "90Amplitude1H",   "Pulse amplitude (dB)",      "tb",  "pulseamp";
               "pulseLength1H",   "Pulse length (us)",         "tb",  "pulselength";
               "startDelay",      "Initial delay (us)",        "tb",  "float,[10,327600]";
               "endDelay",        "Final delay (us)",          "tb", "float,[10,327600]";
               "nrSteps",         "Nr. steps",                 "tb",  "integer,[2,1000]";
               "repTime",         "Repetition time (ms)",      "tb",  "reptime"]


# Define the tab groups and their order
   groups = ["Pulse_sequence","Acquisition",
             "Processing_Std","Display_Std","File_Settings"]

# Relationships to determine remaining variable values
   relationships = ["nDataPnts    = nrPnts",
                    "a90Amp       = 90Amplitude1H",
                    "d90Dur       = pulseLength1H",
                    "delays       = linspace(startDelay,endDelay,nrSteps)",
                    "tDelays      = DelayTableTest_pp:convertDelays(delays-4.45-pgo)",
                    "totPnts      = nrPnts",
                    "totTime      = acqTime"]

# These parameters will be changed between experiments
   variables = [""]

## Pulse sequence - generate nrSteps pulses separated by linearly increasing delays

   initpp(dir)       

   setindex(tDelays,0) 
   loop("l1",nrSteps)
      pulse(1,a90Amp,p1,d90Dur)
      delay(tDelays)
      incindex(tDelays,2)
   endloop("l1")
   pulse(1,a90Amp,p1,d90Dur)

   acquire("overwrite",nDataPnts)   # Acquire FID

   lst = endpp(1)                # Combine commands and return parameter list

# Phase cycle list
   phaseList  = [0,1,2,3;   # p1 : Pulse phase
                 0,1,2,3]   # pA : Acquire phase


endproc(lst,groups,interface,relationships,variables,null,phaseList)

#####################################################
# Converts a delay table in us to a 32 bit integer 
# table of clock cycle delays (multiples of 10ns)
#####################################################

procedure(convertDelays, delays)

   delays = delays*100
   sz = size(delays)
   out = matrix(sz*2)
   for(k = 0 to sz-1)
      hiWord = single((delays[k] & 0xFFFF0000)/2^16d)
      loWord = single(delays[k] & 0xFFFF)
      out[k*2]   = hiWord
      out[k*2+1] = loWord
   next(k)
  
endproc(out)


#####################################################
# Assign those parameters which should take their 
# values from the factory defaults when making a 
# new experiment
#####################################################

procedure(getFactoryBasedParameters, par)

   specPar = gData->getXChannelParameters("1H")
   if(specPar == null)
      return(null)
   endif
   assignlist(specPar)

   modelPar = ucsUtilities:getModelBasedParameters("1H",specPar)

   par = ["rxGain        = $modelPar->rxGain$",
          "pulseLength1H = $PulseLength_1H$",
          "90Amplitude1H = $PowerLevel_1H$",
          "b1Freq1H      = $Frequency_1H$",
          "b1Freq13C     = $Frequency_X$"]

endproc(par)


