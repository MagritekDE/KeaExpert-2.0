#########################################################
# 
# FindF0-H
#
# A pulse sequence suitable for determining the resonant
# frequency using a simple pulse and collect sequence
#
# pulse - delay - acq
#
#
# Copyright (c) Magritek Ltd 2025
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the SpinsolveExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(FindF0-H, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"FindF0-H")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("FindF0-H")
   else
      gExpt->addExperiment(parentPath,"FindF0-H",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds [""] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["n1         = nrPnts",
          "a1         = 90Amplitude1H",
          "d1         = pulseLength1H",
          "d2         = acqDelay",
          "totPnts    = nrPnts",
          "totTime    = acqTime",
          "spoilAmp   = 5000",
          "nxShim     = xshim",
          "nyShim     = yshim",
          "nzShim     = zshim",
          "ny         = (yshim-1.0*spoilAmp)",
          "nx         = (xshim-1.0*spoilAmp)",
          "nz         = (zshim-1.0*spoilAmp)"]
   var = [""]
   pp_list = ["a1","p1","d1","d2","n1","nx","ny","nz","nxShim","nyShim","nzShim"]
   pp_name = "FindF0-H.p"
   phase_list = [0,1,2,3;0,1,2,3]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)


#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
# 12.04.2024 
# 1. Extended to include additional nuclei
# 2. Calibration moved to setupUtilities
#######################################################


procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)

#  Make subplots and define local variables
  (prt,prf) = ucsPlot:getPlotReferences()

# First order phase correction
   guipar = guipar + ["firstOrderCorr = 2*pi"]
  
# Calculate suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000 # ms
   fAxis = [-totPnts/2:totPnts/2-1]/totTime*1000  # Hz

# Time domain filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",tAxis/1e6)
   else
      flt = matrix(totPnts)+1
   endif

# Define the number of searches to make
   nrUpdates = 1
   guipar = guipar + "nrUpdates = $nrUpdates$"

# Update the frequency from defaults if desired
   if(isvar("findFromDefaults") == 0)
      findFromDefaults = "no"
   endif
   if(findFromDefaults == "yes")
      b1Freq1H = gData->specParameters->Frequency_1H 
      n = findobj(0,"name","b1Freq1H")
      if(n > 0)
         setpar(0,n,"text","$b1Freq1H,1.7f$")
      endif 
   endif

# Set verbose flag
   if(isvar("verbose") == 0)
      verbose = 1
   endif

# The first pass gets the frequency, the second shows it
   for(update = 0 to nrUpdates-1)

   # Set the Tx and Rx frequencies
      if(wvProcType == "DSP")
         ppList = ucsRun:setPPFrequency(ppList,9,b1Freq1H)
         ppList = ucsRun:setPPFrequency(ppList,13,b1Freq1H*freqScaleFactor)
      else
         seFX3:setStartCodeFreq(self=gFX3, flatFilter=flatFilter, tx1Freq=b1Freq1H, rxFreq=b1Freq1H)
      endif

   # Storage for output data
      sumData = cmatrix(totPnts)

   # Accumulate scan
      for(scan = 0 to nrScans-1)
   
     # Check timing, update the parameters, run the sequence and return the data
       (data,pAcq,status) = ucsRun:runSequence(guipar,ppList,pcList,pcIndex,scan)
 
       # See if stop button/escape key pressed
         if(status == "abort")
            return(0)
         endif
   
       # Filter the data
         data = data .* flt
   
       # Accumlate the data
         sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)
   
       # Process data
         (phasedTimeData,spectrum) = ucsRun:transformData(sumData,fAxis,guipar,"fid")
   
         tmTitle = "FID for a bandwidth of $1000/dwellTime$ kHz"
         ucsPlot:graphTimeAndFreq(prt,prf,tAxis,phasedTimeData,fAxis,spectrum,scan,guipar,tmTitle)
 
      # Check if complete button pressed
         if(status == "finish")
            scan = scan+1
            exitfor()
         endif

      next(scan)

   # Find the peak position
      if(fdPhaseCorr == "none" | fdPhaseCorr == "mag")
        (v,x) = max(mag(spectrum))
      else
        (v,x) = max(real(spectrum))
      endif

   # Update the 1H frequency based on this measurement
      b1Freq1H = b1Freq1H + (fAxis[x] - (peakPositionPPM-4.74)*b1Freq1H)/1e6

   next(update)

   setupUtilities:calibrate(guipar, b1Freq1H, verbose)
                      
# Update the user interface with the new frequency
   n = findobj(0,"name","b1Freq1H")
   if(n > 0)
      setpar(0,n,"text","$b1Freq1H,1.7f$")
   endif

# Update the plot titles
   if(prf != null)
      prf->title("B1 frequency = $b1Freq1H$ MHz")
   endif
   if(prf != null)
      prf->title("Spectrum for a bandwidth of $1000/dwellTime$ kHz")
   endif

# Save the data
   ucsFiles:savePlot(prt,:getPlotInfo("pt1"),guipar,"noReport")
   ucsFiles:savePlot(prf,:getPlotInfo("pt2"),guipar,"simpleReport")

# Return the data
   r = struct()
   r->tData = sumData/scan
   r->fAxis = fAxis
   r->fData = spectrum
   r->freq  = b1Freq1H

   return(r)

endproc("execpp")


########################################################
# Return expected experiment duration
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = nrScans + useStartDelay
   duration = (totScans*repTime)/1000

endproc(duration)

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt1","fid.pt1","pt2","spectrum.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)

########################################################
# Return expected experiment duration in seconds
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = nrScans + useStartDelay
   duration = (totScans*repTime)/1000

endproc(duration)

##################################################################
# Returns the linewidth at 10% and 50% of peak height (in Hz)
# fAxis is assumed to be in kHz.
##################################################################

procedure(getLineWidth,guipar,spectrum,fAxis)

   sz = size(fAxis)
  (peak,peakPos) = max(real(spectrum))

   baseline = spectrum[0:trunc(sz/10)] + spectrum[-trunc(sz/10),:]
   baseline = sum(baseline)/size(baseline)
   peak = peak-baseline

   flag = 0
   right10 = spectrum[-1]
   left10 = spectrum[0]
   right50 = spectrum[-1]
   left50 = spectrum[0]
   for(k = peakPos to 0 step -1)
      if(spectrum[k]-baseline < peak/2 & flag == 0)
         left50 = (peak/2-spectrum[k])/(spectrum[k+1]-spectrum[k])*(fAxis[k+1]-fAxis[k])+fAxis[k]
         flag = 1
      endif

      if(spectrum[k]-baseline < peak/10 & flag == 1)
         left10 = (peak/10-spectrum[k])/(spectrum[k+1]-spectrum[k])*(fAxis[k+1]-fAxis[k])+fAxis[k]
         flag = 2
         exitfor()
      endif 
   next(k)

   flag = 0
   for(k = peakPos to sz-1)

      if(spectrum[k]-baseline < peak/2 & flag == 0)
         right50 = (peak/2-spectrum[k+1])/(spectrum[k]-spectrum[k+1])*(fAxis[k+1]-fAxis[k])+fAxis[k]
         flag = 1
      endif

      if(spectrum[k]-baseline < peak/10 & flag == 1)
         right10 = (peak/10-spectrum[k+1])/(spectrum[k]-spectrum[k+1])*(fAxis[k+1]-fAxis[k])+fAxis[k]
         flag = 2
         exitfor()
      endif 
   next(k)


endproc((right10-left10)*1000,(right50-left50)*1000) 


