#####################################################################
# This adds the StandbyShim protocol to the parameter list or
# by holding the shift key down allows the protocol to be edited.
#####################################################################

procedure(StandbyShim, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      ProtocolEditor(gView->wn, parentPath, "StandbyShim")
   else
      gExpt->addExperiment(parentPath,"StandbyShim", parameters)
   endif

endproc()

#####################################################################
# The backdoor entry for the StandbyShim protocol. 
# guipar are the parameters from the user interface
#####################################################################

procedure(backdoor, parameters)

# Check we aren't in simulator mode
   if(wvSpecType == "Simulator")
      message("Error","StandbyShim not available in simulator mode.","error")
      return
   endif   

# Run the experiment
   InitScript(getmacropath(),getmacroname()) 
      InitPlot(["pt1","pt2";"pt3"])
      :StandbyShimCore(parameters)
   EndScript()

endproc()

#####################################################################
#
# The StandbyShim procedure
#
# This searches for the best shim values by performing an FID RMS 
# measurement at 3 points for each shim. A parabolic fit is performed
# to determine the minimum RMS values made on each shim.
# This process is repeated for each shim in an order which has
# been found to most likely result in an optimal set of shims.
#
# The shimming process is repeated continuously until stopped by
# the user at which point the best shim in the last group of scans
# is saved and lock refound.
# 
#
# The previously saved shims are used as the starting point
# 
# Different types of shimming protocols can be applied
#
# 1st order ........ First order or linear shims are optimized
# 1st & 2nd order .. Both first and second order shims are optimized
#
# The StandbyShim protocol requires the TestShims experiment be present
# in the search path to perform the shim setting and FID measurement.
#
# The StandbyShim protocol requires the SpinsolveExpert environment.
#
# psPar is a structure containing the user interface parameters
# Returns the shim parameter list on completion or 0 on failure
#
#####################################################################

#########################################################
# Class declarations
# quick : parabolic
#########################################################

procedure(StandbyShimCore, parameters)

# Make parameter list based on the source
   type = vartype(parameters)
   if(type == "list")    
      psPar = struct(parameters)
   elseif(type == "structure") 
      psPar = parameters
   else  
      return(0)
   endif 

   pr("\n\n-------- Standby Shim --------\n")

  # Import the parabolic search class
   import("parabolic.mac","$appdir$\\Macros\\Spinsolve-Expert\\Setup Macros\\SetShims")
   quick = class("parabolic:init")

  # Some local procedures which should be used to check the FID quality
   quick->measureLineWidth = "StandbyShim:measureLineWidth"
   quick->checkShimQuality = "StandbyShim:checkShimQuality"

  # Optimise the FID RMS when finding the best shim
   quick->parameterToOptmise = "RMS"

  # Note the start time
   quick->startTime = time()

  # Stop the lock
   ucsUtilities:disableLock()

  # Load the last shims
   psPar = :loadBestShims(psPar)

  # Check for error
   if(psPar == null)
      return(0)
   endif

  # Get ready to run
   gView->completeButton->enable("false")
   gView->abortButton->enable("false")
   gView->graphLabel->label("Performing StandbyShim")

  # Copy these shim values into the 'quick' object
   :updateShimCurrents(alias(quick),psPar)
   quick->psPar = psPar

  # Update the UI with these shim values
   :updateShimsInUI(quick)

  # Continuous shim loop
   firstTime = 1
   shimStep = 0
   while(1)
  
    # Refind F0
      pr("\n   -------------------------------------\n")
      pr("   Finding the B1 Frequency ...\n")
   
      experimentLabelCtrl->label("StandbyShim: finding B1 frequency")
      (result,quick->psPar,specPar) = :findF0(alias(quick), quick->psPar, hiRes=0)

    # Set the parameters
      quick->verbose = 0
      quick->iteration = 0
      quick->psPar->shimDelay = 50
      deltaFactor = 1
      quick->psPar->pulseLength1H = psPar->pulseLength1H
      quick->psPar->dwellTime = 300
      quick->psPar->nrPnts = 16384
      quick->psPar->acqTime = 4915.2
      quick->psPar->bandwidth = 3.333
      quick->psPar->dispRange = 1000
      quick->psPar->zf = 4
      quick->psPar->saveData = "false"
      quick->repTime = 9
   
    # Perform some dummy scans for the first iteration
      if(firstTime)
         quick->WaitRepTime(1)
         :dummyScans(4,alias(quick))
         gView->completeButton->enable("true")
      endif

    # First order shim search (one time only)
      if(firstTime & wvExpStatus == "running")
         pr("\n   -------------------------------------\n")
         pr("   Shimming the magnet, 1st order shims ...\n")
         quick->shimsToOptimise = ["z","x","y","z2"]
         quick->shimDeltas = [20,10,10,200]*deltaFactor
         :updateUI(quick)
         r = quick->Search()
         firstTime = 0
      endif
   
    # First and second order shims search (repeating)
      if(wvExpStatus == "running" & psPar->shimMethod == "order12")
         pr("\n   -------------------------------------\n")
         pr("   Shimming the magnet, 1st and 2nd order shims ...\n")
         quick->shimsToOptimise = ["z","x","y","z2","zx","zy","x2y2","xy"]
         quick->shimDeltas = [6,2,2,70,30,30,25,25]
         :updateUI(quick)
         r = quick->Search()
      endif

    # First, second and third order shims search (repeating)
      if(wvExpStatus == "running" & psPar->shimMethod == "order123")
         pr("\n   -------------------------------------\n")
         pr("   Shimming the magnet, 1st, 2nd and 3rd order shims ...\n")
         quick->shimsToOptimise = ["z","x","y","z2","zx","zy","x2y2","xy","z3","z2x","z2y","zx2y2","zxy","x3","y3"]
         quick->shimDeltas = [6,2,2,70,30,30,25,25,500,400,400,200,200,150,150]
         :updateUI(quick)
         r = quick->Search()
      endif

    # Check for abort or finish
      if(wvExpStatus == "finish" | wvExpStatus == "stop")
         exitwhile()
      endif

   endwhile() # Continuous shim loop

  # Save the plot data
   pt3 = gView->g3->subplot(1,1)
   :saveShimData(pt3, quick->psPar)

  # Save the shims values
   shimPar = :saveShims(quick,result)

  # Find the lock
   pr("\n   Finding lock ...\n")
   experimentLabelCtrl->label("StandbyShim: finding lock")
   gLock->findLock()
   pr("   Lock found\n")

  # Restore the shim data
   InitPlot(["pt1","pt2";"pt3"])
   cd(gData->curExpt->dataPath)
   gView->g3->load("StandbyShim.pt1")

  # Calibrate
   pr("\n   Refinding the B1 Frequency ...\n")
   experimentLabelCtrl->label("StandbyShim: recalibrating")
   (result,psPar,specPar) = :findF0(alias(quick), quick->psPar, hiRes=1)
   pr("\n   Calibrating ...\n")
   :calibrate(psPar)
   pr("   Calibration complete\n")

  # Collect a long reference FID and save it
   if(psPar->collectRef == "yes")
      experimentLabelCtrl->label("StandbyShim: final measurement")
      pr("\n   Reference FID measurement\n")
      pr("    15 second T1 delay ...\n")
      pause(15)
      pr("    FID measurement ...\n")

      quick->psPar->saveData = "true"
      quick->psPar->b1Freq1H = psPar->b1Freq1H
      quick->psPar->dwellTime = 200
      quick->psPar->nrPnts = 65536
      quick->psPar->acqTime = 13107
      quick->psPar->bandwidth = 5
      quick->psPar->zf = 2
   
      (value,result) = :checkShimQuality(quick, quick->shimCurrents)
   
      pr("      Reference linewidth (50%/0.55%) = ($result->lw50,1.2f$ Hz/$result->lw0.55,1.2f$ Hz)\n")

      # Save the reference FID to gData
      pt1 = gView->g1->subplot(1,1)
      (x,y) = pt1->getdata()
      # Correct for loss of first point
      dw = quick->psPar->dwellTime/1000
      N = quick->psPar->nrPnts 
      x = linspace(0,dw*(N-1),N)
      y = join(y,{y[-1]})
      gData->refFIDxAxis = x
      gData->refFIDyAxis = y
   endif

  # Save the shim data in the plot in case reference FID was added
   pt3 = gView->g3->subplot(1,1)
   :saveShimData(pt3, quick->psPar)

  # Finalise the progress bar
   experimentLabelCtrl->label("StandbyShim Complete")

   pr("\n-------- Standby Shim Finished --------\n")

endproc(shimPar)

#####################################################################
# Calculate the linewidth from the last findF0 result
#####################################################################

procedure(calcLineWidth, result)

   setupUtilities:calcLineWidth(result)

endproc()


#########################################################
# Update the common parameters with the found frequency
#########################################################

procedure(calibrate, psPar)

   setupUtilities:calibrate(psPar)
   
endproc()

############################################################################################################
#  Update the UI and spectrometer with the currently 
#  determined shim values and then measure the 
#  shim quality (Linewidth, Peak and RMS).
#  Returns the parameter being optimised (LW , Peak or RMS)
############################################################################################################

procedure(checkShimQuality, quick, shimCurrents)

## Update the shim values used in experiment
   for(m = 1 to size(shimCurrents)-1)
      name = quick->shimNames[m]
      assign("quick->psPar->$name$",round(shimCurrents[m]),"local")
      n = findobj(0,"name",name)
      if(n > 0)
         setpar(0,n,"text",round(shimCurrents[m]))
      endif
   next(m)

# Measure the linewidth and time domain RMS
   result = :measureLineWidth(quick,quick->psPar)

# Return the optimised parameter
   ptoopt = quick->parameterToOptmise
   if(ptoopt == "FWHM")
      value = result->lw50
   elseif(ptoopt == "Base")
      value = result->lw0.55
   elseif(ptoopt == "RMS")
      value = 1/result->RMS
   else
      value = 1/result->maxAmp
   endif

  # :interExptDelay(10)

endproc(value, result)

#########################################################
# Interexperiment delay with monitoring
#########################################################

procedure(interExptDelay, duration)

   if(isvar("ppStatus"))
      ppStatus->color([255,255,0])
   endif
   start = time()
   while(1)
      remainingTime = duration-(time()-start)
      if(remainingTime <= 0)
         exitwhile()
      elseif((remainingTime > 2) & (gExpt->pauseMonitor == 1))
         gExpt->resumeMonitoring(1)
      elseif((remainingTime < 1) & (gExpt->pauseMonitor == 0))
         gExpt->pauseMonitoring()
      endif
   endwhile

endproc()


#########################################################
# Perform some dummy scans
#########################################################

procedure(dummyScans, N, quick)

   print("   Performing $N$ dummy scans\n")
   for(k = 1 to N)
      experimentLabelCtrl->label("StandbyShim: dummy scan $k$/$N$")
      if(k > 1)
         quick->WaitRepTime()
      endif
      TestShims:backdoor(list(quick->psPar))  
   next(k)

endproc()

#########################################################
# Search for the resonant frequency using dwellTimes 
# 2, and 100/200 us (depending on highRes argument)
#########################################################

procedure(findF0, shimObj, psPar, hiRes=0, saveData="false")

   usePPMScale = psPar->usePPMScale
   (result, psPar, specPar) = setupUtilities:findF0(shimObj, psPar, hiRes, saveData)
   psPar->usePPMScale = usePPMScale

endproc(result, psPar, specPar)

#########################################################
# Generate a user interface from the interface description
# macro for exptName and load the parameters 'par' into it
########################################################

procedure(generateUI, exptName, par)

   dir = "$appdir$\\Macros\\Setup\\$exptName$"
   cd(dir)
   proc = "$exptName$_interface:interfaceDescription"
   itfc = proc()
   exptInfo = struct(protocol = "$exptName$")
   gView->makeUIFromParList(itfc,exptInfo)
   gView->exptPanel->panelupdate("")
   setctrlvalues(0,par)
   for(k = gParam->firstParameterCtrl to gParam->lastParameterCtrl)
      if(getpar(0,k,"tag") == "hidden")
         setpar(0,k,"visible","false")
      else
         setpar(0,k,"visible","true")
      endif
      if(getpar(0,k,"tag") == "disabled")
         setpar(0,k,"enable","false")
      else
         setpar(0,k,"enable","true")
      endif
   next(k)

endproc()

#########################################################
# Get initial shims based on the startMethod parameter
# Also update other factory based parameters
#########################################################

procedure(getFactoryBasedParameters, par)

   specPar = gData->getXChannelParameters("1H")
   if(specPar == null)
      return(null)
   endif
   assignlist(specPar)

   modelPar = ucsUtilities:getModelBasedParameters("1H",specPar)

   par2 = ["rxGain = $modelPar->rxGain$",
           "pulseLength1H = $PulseLength_1H$",
           "90Amplitude1H = $PowerLevel_1H$",
           "b1Freq1H = $Frequency_1H$"]

   method = getlistvalue(par,"startMethod")
   method = "last"
   if(method != null)
      if(method == "factory") # Apply the factory shims before the QuickDhim search
         psPar = StandbyShim:loadFactoryShims(null)
      elseif(method == "database") # Read the shims from the standard software
         psPar = StandbyShim:importSpinsolveShims(null)
      else
         psPar = StandbyShim:loadBestShims(null)
      endif
      if(psPar == null)
         return(par2)
      endif
      par = mergelists(par2,list(psPar))
      return(par)
   endif

endproc(null)


#########################################################
# Get the name of a plot file given the region name
# or return the whole list
#########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt1","fid.pt1",
           "pt2","spectrum.pt1",
           "pt3","StandbyShim.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)

   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)


#############################################################
# Import shim parameters from Standard Spinsolve software
#
# psPar is a structure containing the current UI parameters
# Returns a structure with the shim parameters updated.
#############################################################

procedure(importSpinsolveShims, psPar)

   par = setupUtilities:importSpinsolveShims(psPar)

endproc(struct(par))


#############################################################
# Load the default parameters for StandbyShim
#############################################################

procedure(loadDefaults, exptName)

   dir = getcwd()
   cd(getmacropath())
   pref = load("$exptName$Default.par")

endproc(pref)


#########################################################
# Read the DSP parameters and return as a list
# or structure based on the mode
#########################################################

procedure(loadDSPParameters, mode="list")

   specPar = setupUtilities:loadDSPParameters(mode)

endproc(specPar)

#########################################################
# Load the shim settings from the DSP parameter list
#########################################################

procedure(loadFactoryShims, psPar)

   psPar = setupUtilities:loadFactoryShims(psPar)

endproc(psPar)


#########################################################
# Load the shim values from a file in the preferences
# SpinsolveExpert shim folder
#########################################################

procedure(loadBestShims, psPar)

   par = setupUtilities:loadShims()

   if(par == null)
      return(null)
   endif

# Extract the shims value
   shimNames = ["xshim", "yshim",  "zshim",
                 "z2shim", "zxshim", "zyshim", "x2y2shim",
                 "xyshim", "z3shim", "z2xshim", "z2yshim",
                 "zx2y2shim", "zxyshim", "x3shim", "y3shim"]

   par = getsublist(par,shimNames)
   if(psPar != null)
      par = mergelists(par,list(psPar))
      psPar = struct(sortlist(par))
   else
      psPar = struct(sortlist(getsublist(par,shimNames)))
   endif

endproc(psPar)


#############################################################
# Load a shims parameters into the GUI
#############################################################

procedure(loadCurrentShims)

   bak = getcwd()

   shimDir = "$prefdir$\\SpinsolveParameters\\Shims"
   mkdir(shimDir)
   cd(shimDir)

   file = getfilename("load","Load shim parameter file from ...","Parameter files","par")
   if(file != "cancel")
      par = load(file)

      shimNames = ["xshim", "yshim",  "zshim",
                    "z2shim", "zxshim", "zyshim", "x2y2shim",
                    "xyshim", "z3shim", "z2xshim", "z2yshim",
                    "zx2y2shim", "zxyshim", "x3shim", "y3shim"]

      par = getsublist(par,shimNames) 

      setctrlvalues(0,par)

   endif

   cd(bak)

endproc()

#########################################################
# Collect an FID and then plot the linewidth, peak 
# and RMS
#########################################################

procedure(measureLineWidth, quick, psPar)

# Set the shims and measure the linewidth
   result = TestShims:backdoor(list(psPar))

# Check for aborts
   if(wvExpStatus == "stop")
      throw("Abort pressed")
   endif
   if(wvExpStatus == "finish")
      throw("Finish pressed")
   endif

# Add the linewidth measurement to the current data
   pt3 = gView->g3->subplot(1,1)
   lst = pt3->tracelist()
   if(size(lst) == 0) # First time
      sz    = 1
      x     = [0]
      y50   = [result->lw50]
      y0.55 = [result->lw0.55]
   else
      (x,y50)   = pt3->trace(0)->getdata()
      (x,y0.55)   = pt3->trace(1)->getdata()
      sz    = size(x)
      x     = join(x,[sz])
      y50   = join(y50,[result->lw50])
      y0.55 = join(y0.55,[result->lw0.55])
   endif

# Plot the latest linewidth
   pt3->draw("false")
   pt3->plot(x,y50,"color",[128,0,0])
   pt3->hold("on")
   pt3->plot(x,y0.55,"color",[0,128,0])
   pt3->axes->ymapping("log")
   pt3->xlabel("Iteration")
   pt3->ylabel("FWHM (Hz)")
   if(result->lw50 < 1)
      pt3->title("Linewidth (50% : $result->lw50,1.2f$ Hz 0.55% : $result->lw0.55,1.1f$ Hz)")
   elseif(result->lw50 < 10)
      pt3->title("Linewidth (50% : $result->lw50,1.1f$ Hz 0.55% : $result->lw0.55,1.1f$ Hz)")
   else
      pt3->title("Linewidth (50% : $result->lw50,1.0f$ Hz 0.55% : $result->lw0.55,1.0f$ Hz)")
   endif
   pt3->grid->xgrid("on")
   pt3->grid->ygrid("on")
   pt3->grid->finexgrid("on")
   pt3->grid->fineygrid("on")
   pt3->zoom(0,sz,0.1,50)
   pt3->hold("off")
   pt3->draw("true")

# Save the linewidth history into the simplex object 
   quick->lw0.55  = y0.55
   quick->lw50  = y50

# Increment the number of steps taken
   quick->iteration = quick->iteration + 1

endproc(result)

#############################################################
# Save the shim data
#############################################################

procedure(saveShimData, pt3, psPar)

   bak = getcwd()

# Get the SPA name
   dspPar = :loadDSPParameters("struct")
   if(dspPar == null)
      return
   endif

# Get the location to save the data
   if(isdir(psPar->dataDirectory) == 0)
      cd("$prefdir$\\SpinsolveParameters")
      mkdir("Shims\\ShimData")
      cd("Shims\\ShimData")
      psPar->dataDirectory = getcwd()
      name = "StandbyShim$dspPar->SystemID$"
   else
      name =  :getPlotInfo("pt3")
   endif

# Save the data
   psPar->saveData = "true"
   ucsFiles:savePlot(pt3,name,list(psPar))

   cd(bak)

endproc()


#############################################################
# Save the shims parameters in the GUI
#############################################################

procedure(saveCurrentShims)

   bak = getcwd()

   par = getctrlvalues(0,"list","range",[gParam->firstParameterCtrl,gParam->lastParameterCtrl])

   shimNames = ["xshim", "yshim",  "zshim",
                 "z2shim", "zxshim", "zyshim", "x2y2shim",
                 "xyshim", "z3shim", "z2xshim", "z2yshim",
                 "zx2y2shim", "zxyshim", "x3shim", "y3shim"]

   par = getsublist(par,shimNames) 

   shimDir = "$prefdir$\\SpinsolveParameters\\Shims"
   mkdir(shimDir)
   cd(shimDir)

   file = getfilename("save","Save shim parameter file as ...","Parameter files","par")
   if(file != "cancel")
      save(file,par)
   endif

   cd(bak)

endproc()

#############################################################
# Save the shims parameters
#############################################################

procedure(saveShims, power, lwInfo)

# Make a shim list from the power object
   sz = size(power->shimCurrents)
   shimValues = list(sz-1)
   for(k = 1 to sz-1)
      name = power->shimNames[k]
      value = power->shimCurrents[k]
      shimValues[k-1] = "$name$ = $round(value)$"
   next(k)

# Add the linewidths
   shimValues = ["lw50 = $lwInfo->lw50$","lw0.55 = $lwInfo->lw0.55$"] + shimValues

# Get the SPA name
   dspPar = :loadDSPParameters("struct")
   if(dspPar == null)
      return
   endif

# Save the shims
   fileName = "$dspPar->SystemID$Shim.par"
   setupUtilities:saveShims(fileName,shimValues,lwInfo->lw50)

endproc(shimValues)


########################################################
# Update the shimCurrents in quick based on the values
# in psPar
#########################################################

procedure(updateShimCurrents,quick,psPar)

   for(k = 1 to size(quick->shimCurrents)-1)

      name = "psPar->$quick->shimNames[k]$"
      value = eval(name)
      quick->shimCurrents[k] = value 

   next(k)

endproc()

########################################################
# Update the shimCurrents in the user interface if
# text field with the correct names are present
#########################################################

procedure(updateShimsInUI, quick)

## Update the shim values used in experiment
   for(m = 1 to size(quick->shimCurrents)-1)
      name = quick->shimNames[m]
      n = findobj(0,"name",name)
      if(n > 0)
         setpar(0,n,"text",round(quick->shimCurrents[m]))
      endif
   next(m)

endproc()

#########################################################
# Update the parameter list in the UI with latest shims
# and acquisition parameters
#########################################################

procedure(updateUI, quick)

   lst = list(quick->psPar)
   setctrlvalues(0,lst)

endproc()



########################################################
# Return expected experiment duration
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)

   duration = 20

endproc(-duration) # Repeats forever

