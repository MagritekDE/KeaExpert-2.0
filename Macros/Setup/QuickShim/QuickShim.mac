##################################################################################
# The QuickShim protocol performs a series of parabolic shim 
# optimisations for a specified number of shims, that is for each
# shim to be optimised 3 measurements are made. One at the current
# shim value and one either side of the current value. A parabola
# is fitted to these values and the best shim value found. If all
# points are increasing or decreasing them the algorithm will search
# to the left or right until a peak is found. Options are:
# Shim speed mode
#   This controls the delay after each scan to allow time for the 
#   signal to equilibriate. The slow mode should be used with chloroform
#   while the medium and fast modes are for water. Note the fast mode
#   acquires for a shorter time and skips some steps so the final
#   linewidth will probably be worse than the medium mode.
# Shim start mode
#   This determines where the start shim values will be taken from.
#   Either the last Expert shim, the last Standard Software shim or
#   shim which have been loaded from the UI. (Note you need to show
#   all parameter to see this option).
# Shim search mode
#   This determines which shims will be optimised. This obviously has
#   a large impact on the duration of the shimmming process. Options 
#   are:
#     short sample (z2, z3, z, x ,y)
#     1st order and z2 (z, x, y, z2)
#     1st and 2nd order (z, x, y, z2, zx, zy, x2y2, xy)
#     All shims (z, x, y, z2, zx, zy, x2y2, xy, z3, z2x, z2y, zx2y2, zxy, x3, y3]
#
##################################################################################

procedure(QuickShim, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)
   if(iskeypressed("shift"))
      ProtocolEditor(gView->wn, parentPath, "QuickShim")
   else
      gExpt->addExperiment(parentPath,"QuickShim", parameters)
      par = struct(getctrlvalues(0))
      :enableManualCtrl(par->peakPositionPPM == "yes")
   endif

endproc()


#####################################################################
#
# The QuickShim procedure
#
# This searches for the best shim values by performing an FID RMS 
# measurement at 3 points for each shim. A parabolic fit is performed
# to determine the minimum RMS values made on each shim.
# This process is repeated for each shim in an order which has
# been found to most likely result in an optimal set of shims.
#
# The QuickShim protocol requires the TestShims experiment be present
# in the seach path to perform the shim setting and FID measurement.
#
# The QuickShim protocol requires the SpinsolveExpert environment.
#
# psPar is a structure containing the user interface parameters
# Returns the shim parameter list on completion or 0 on failure
#
#####################################################################

#########################################################
# Class declarations
# quick : parabolic
#########################################################

procedure(QuickShimCore, parameters)

# Make parameter list based on the source
   type = vartype(parameters)
   if(type == "list")    
      psPar = struct(parameters)
   elseif(type == "structure") 
      psPar = parameters
   else  
      return(0)
   endif  

   pr("\n\n-------- Quick Shim --------\n")


# Import the parabolic search class
   import("parabolic.mac","$appdir$\\Macros\\Spinsolve-Expert\\Setup Macros\\SetShims")
   quick = class("parabolic:init")

# Set the repetition time
   quick->repTime = psPar->repTime/1000

# Some local procedures which should be used to check the FID quality
   quick->measureLineWidth = "QuickShim:measureLineWidth"
   quick->checkShimQuality = "QuickShim:checkShimQuality"

# Optimise the FID RMS when finding the best shim
   quick->parameterToOptmise = "RMS"

# Stop the lock and start the clock
   quick->startTime = time()

# Record the current shims in case of abort
   shimsBackup = setupUtilities:loadShims("noUIUpdate")

# Select start values for shims 
   if(psPar->startMethod == "factory") # Apply the factor shims before the simplex search
      psPar = :loadFactoryShims(psPar)
   elseif(psPar->startMethod == "database") # Read the shims from the standard software
      psPar = :importSpinsolveShims(psPar)
   elseif(psPar->startMethod == "last") # Read the shims from the Expert shim file
      psPar = :loadBestShims(psPar)
   endif # Otherwise use the current values

# Check for error
   if(psPar == null)
      return(0)
   endif

# Get ready to run
   gView->completeButton->enable("false")
   gView->graphLabel->label("Performing QuickShim")

# Copy the shim values into the 'quick' object
   :updateShimCurrents(alias(quick),psPar)

# Get spec parameters for Proton
   specPar = gData->getXChannelParameters("1H")

# Initialise pulse parameters
   psPar->b1Freq1H = double(gData->commonPar->b1Freq1H)
   psPar->90Amplitude1H = specPar->PowerLevel_1H
   psPar->pulseLength1H = specPar->PulseLength_1H*0.5
   psPar->findingF0 = 0
   quick->psPar = psPar

# Initialise some parameters from the UI
   quick->psPar->shimDelay = psPar->shimDelay
   quick->psPar->dwellTime = psPar->dwellTime
   quick->psPar->nrPnts = psPar->nrPnts 
   quick->psPar->acqTime = psPar->acqTime
   quick->psPar->bandwidth = psPar->bandwidth
   quick->psPar->usePPMScale = "yes"

# Initialise processing parameters
   quick->psPar->dispRange = 1000
   quick->psPar->zf = 2
   quick->psPar->saveData = "false"
   quick->psPar->filter = "no"
   quick->psPar->filterType = "exp:0.1"
   quick->calSaved = 0 # This is a flag to say we need to save the first FID for calibration
   quick->calFID = null
   quick->calTimeAxis = null

# Short duration experiment
   shortExpPar = quick->psPar
   shortExpPar->dwellTime = 1
   shortExpPar->nrPnts = 256 

# Update the UI with these values
   :updateUI(quick->psPar)

# Allow abort by enabling the complete button
   gView->completeButton->enable("true")

# First-order/short shim search
   if(wvExpStatus == "running")
      pr("\n   -------------------------------------\n")
      if(psPar->shimMethod == "short")  
         pr("   Shimming the magnet, short sample shim ...\n")
         quick->shimsToOptimise = ["z2","z3","z","x","y"]
         quick->shimDeltas = [200,500,20,10,10]
      else
         pr("   Shimming the magnet, 1st order shims ...\n")
         quick->shimsToOptimise = ["z","x","y","z2"]
         quick->shimDeltas = [20,10,10,200]
      endif

    # Initialise repTime delays
      quick->WaitRepTime(init=1)

    # Measure reference scan
      result = TestShims:backdoor(list(quick->psPar))

    # Save data for later B1 calibration
     (quick->calTimeAxis,quick->calFID) = gView->g1->subplot(1,1)->getdata()

    # Dummy scan
      quick->WaitRepTime()
      result = TestShims:backdoor(list(shortExpPar))

    # Find lock
      gLock->findLock(nrMonitorScans=0)

    # Disable the lock while shimming
      ucsUtilities:disableLock()

    # Update UI plot layout
      InitPlot(["pt1","pt2";"pt3","pt4";"pt5","pt6"])

    # Perform first order shimming
      pr("\n   --- First order magnet shimming ...\n")
      r = quick->Search()
   endif

# First and second order shims
   if((psPar->shimMethod == "order12" | psPar->shimMethod == "order123") & wvExpStatus == "running")
      pr("\n   -------------------------------------\n")
      pr("   Shimming the magnet, 1st and 2nd order shims ...\n")
      quick->shimsToOptimise = ["z","x","y","z2","zx","zy","x2y2","xy"]
      quick->shimDeltas = [6,2,2,70,30,30,25,25]
      :updateUI(quick->psPar)
      quick->Search()
   endif

# First, second and third order shims
   if(psPar->shimMethod == "order123" & wvExpStatus == "running")
      pr("\n   -------------------------------------\n")
      pr("   Shimming the magnet, 1st, 2nd and 3rd order shims ...\n")
      quick->shimsToOptimise = ["z","x","y","z2","zx","zy","x2y2","xy","z3","z2x","z2y","zx2y2","zxy","x3","y3"]
      quick->shimDeltas = [6,2,2,70,30,30,25,25,500,400,400,200,200,150,150]
      :updateUI(quick->psPar)
      quick->Search()
   endif

# Check for abort
   if(wvExpStatus == "stop")
      RunExpt("updateShims",shimsBackup) 
      print("   Restarting lock ...\n")
      gLock->findLock()
      CheckLockAndTemperature(0,0)
      print("   Finished\n")
      experimentLabelCtrl->label("QuickShim aborted")
      return(0)
   endif

# Save the plot data
   if(wvExpStatus == "finish" | wvExpStatus == "running")
      pt1 = gView->g1->subplot(1,1)
      pt2 = gView->g2->subplot(1,1)
      pt3 = gView->g3->subplot(1,1)
      pt4 = gView->g4->subplot(1,1)
      pt5 = gView->g5->subplot(1,1)
      :saveShimData(pt1,pt2,pt3, pt4, pt5, psPar)
   endif

# Enable the lock again
   pr "\n   Enabling lock\n"
   ucsUtilities:enableLock()

# Save the shims
   result = struct()
   result->lw50 = quick->lw50[-1]
   result->lw0.55 = quick->lw0.55[-1]
   shimPar = :saveShims(quick,result)

# Perform a cross-correlation of the last and first FID measurements
# to determine how far the reference frequency has drifted.
   if(psPar->manualCalibration == "no")
    
    # Get a new reference FID
      quick->WaitRepTime()
      result = TestShims:backdoor(list(quick->psPar))
      (lastAxis,lastFID) = gView->g1->subplot(1,1)->getdata()
      sz = size(lastAxis) + 1

    # Fix up size of reference and last FID by adding first point 
      tmAxis = join([0], lastAxis)
      quick->calFID = join({quick->calFID[0]},quick->calFID)
      lastFID = join({lastFID[0]},lastFID)
      sz = size(quick->calFID)*4
      quick->calFID = fill(quick->calFID,sz,"end",0)
      lastFID = fill(lastFID,sz,"end",0)

    # Perform the cross correlation and work out frequency shift
      gYf = lastFID
      gX = tmAxis
      gY = quick->calFID
      ac = gY.*conj(gYf)
      dt = gX[1] - gX[0]
      f = ([0:1:sz-1]-sz/2)/(sz*dt)
      (v,maxPos) = max(real(ft(ac)))
      shiftX = f[maxPos]*1e3
      psPar->b1Freq1H = psPar->b1Freq1H - shiftX/1e6d
      pr "\n   Applying a frequency correction of $-shiftX,1.1f$ Hz\n"
      :calibrate(psPar)

   else # If manual calibration selected then run FindF0

      experimentLabelCtrl->label("Calibrating ...")
      pr("\n   Refinding the B1 Frequency ...\n")
      (result,psPar,specPar) = :findF0(alias(quick), quick->psPar, hiRes=1, saveData="true")
      pr("\n   Calibrating ...\n")
      :calibrate(psPar)
      pr("   Calibration complete\n")

   endif

   experimentLabelCtrl->label("QuickShim Complete")

   pr("\n-------- Quick Shim Finished --------\n")

# Make sure the data is reloaded
   gData->curExpt->parameters->saveData = "true"

# Recheck the lock and temp
   pause(2)
   CheckLockAndTemperature(0,1)

endproc(shimPar)


#####################################################################
# The backdoor entry for the QuickShim protocol. 
# guipar are the parameters from the user interface
#####################################################################

procedure(backdoor, parameters)

# Check we aren't in simulator mode
   if(wvSpecType == "Simulator")
      message("Error","QuickShim not available in simulator mode.","error")
      return(null)
   endif   

# Run the experiment
   InitScript(getmacropath(),getmacroname()) 
      InitPlot(["pt1";"pt2"])
      shimPar = :QuickShimCore(parameters)
   EndScript()

endproc(shimPar)

#####################################################################
# Calculate the linewidth from the last findF0 result
#####################################################################

procedure(calcLineWidth, result)

   setupUtilities:calcLineWidth(result)

endproc()


#########################################################
# Update the common parameters with the found frequency
#########################################################

procedure(calibrate, psPar)

   setupUtilities:calibrate(psPar)
   
endproc()

############################################################################################################
#  Update the UI and spectrometer with the currently 
#  determined shim values and then measure the 
#  shim quality (Linewidth, Peak and RMS).
#  Returns the parameter being optimised (LW , Peak or RMS)
############################################################################################################

procedure(checkShimQuality, quick, shimCurrents)

## Update the shim values used in experiment
   for(m = 1 to size(shimCurrents)-1)
      name = quick->shimNames[m]
      assign("quick->psPar->$name$",round(shimCurrents[m]),"local")
      n = findobj(0,"name",name)
      if(n > 0)
         setpar(0,n,"text",round(shimCurrents[m]))
      endif
   next(m)

# Measure the linewidth and time domain RMS
   result = :measureLineWidth(quick,quick->psPar)

# Return the optimised parameter
   ptoopt = quick->parameterToOptmise
   if(ptoopt == "FWHM")
      value = result->lw50
   elseif(ptoopt == "Base")
      value = result->lw0.55
   elseif(ptoopt == "RMS")
      value = 1/result->RMS
   else
      value = 1/result->maxAmp
   endif

endproc(value, result)

procedure(enableManualCtrl, status)

   n = findobj(0,"name","peakPositionPPM")
   if(status == 1)
      setpar(0,n,"enable","yes")
      setpar(0,n-1,"enable","yes")
   else
      setpar(0,n,"enable","no")
      setpar(0,n-1,"enable","no")
   endif

endproc()


########################################################
# Return expected experiment duration
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)

   duration = 200
   if(shimSample == "other")
      if(shimMethod == "order1")
         duration = repTime*(4*3+3)/1000+4
      elseif(shimMethod == "order12")
         duration = repTime*(4*3)/1000 + repTime*(8*3+3)/1000+4
      elseif(shimMethod == "order123")
         duration = repTime*(4*3)/1000 +  + repTime*(8*3)/1000 + repTime*(15*3+3)/1000+4
      endif

   else #if(shimSample == "reference")
      if(shimMethod == "order1")
         duration = 150
      elseif(shimMethod == "order12")
         duration = 400
      elseif(shimMethod == "order123")
         duration = 700
      endif
   endif

   if(manualCalibration == "yes")
      duration = duration + 12
   endif

   gData->curExpt->parameters->useEndDelay = 1

endproc(duration+2) # Last pause is 2 seconds

#########################################################
# Search for the resonant frequency using dwellTimes 
# 2, and 100/200 us (depending on highRes argument)
#########################################################

procedure(findF0, shimObj, psPar, hiRes=0, saveData="false")

   usePPMScale = psPar->usePPMScale
   (result, psPar, specPar) = setupUtilities:findF0(shimObj, psPar, hiRes, saveData)
   psPar->usePPMScale = usePPMScale

endproc(result, psPar, specPar)

#########################################################
# Generate a user interface from the interface description
# macro for exptName and load the parameters 'par' into it
########################################################

procedure(generateUI, exptName, par)

   dir = "$appdir$\\Macros\\Setup\\$exptName$"
   cd(dir)
   proc = "$exptName$_interface:interfaceDescription"
   itfc = proc()
   exptInfo = struct(protocol = "$exptName$")
   gView->makeUIFromParList(itfc,exptInfo)
   gView->exptPanel->panelupdate("")
   setctrlvalues(0,par)
   for(k = gParam->firstParameterCtrl to gParam->lastParameterCtrl)
      if(getpar(0,k,"tag") == "hidden")
         setpar(0,k,"visible","false")
      else
         setpar(0,k,"visible","true")
      endif
      if(getpar(0,k,"tag") == "disabled")
         setpar(0,k,"enable","false")
      else
         setpar(0,k,"enable","true")
      endif
   next(k)

endproc()

#########################################################
# Get initial shims based on the startMethod parameter
# Also update other factory based parameters
#########################################################

procedure(getFactoryBasedParameters, par)

   specPar = gData->getXChannelParameters("1H")
   if(specPar == null)
      return(null)
   endif
   assignlist(specPar)

   modelPar = ucsUtilities:getModelBasedParameters("1H",specPar)
   par2 = ["rxGain = $modelPar->rxGain$",
           "pulseLength1H = $PulseLength_1H$",
           "90Amplitude1H = $PowerLevel_1H$",
           "b1Freq1H = $Frequency_1H$"]

   method = getlistvalue(par,"startMethod")
   if(method != null)
      if(method == "factory") # Apply the factory shims before the QuickDhim search
         psPar = QuickShim:loadFactoryShims(null)
      elseif(method == "database") # Read the shims from the standard software
         psPar = QuickShim:importSpinsolveShims(null)
      else
         psPar = QuickShim:loadBestShims(null)
      endif
      if(psPar == null)
         return(par2)
      endif
      par = mergelists(par2,list(psPar))
      return(par)
   endif

endproc(null)


#########################################################
# Get the name of a plot file given the region name
# or return the whole list
#########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt1","fid.pt1",
           "pt2","spectrum.pt1",
           "pt3","quickShim50.pt1",
           "pt4","quickShim0_55.pt1",
           "pt5","quickShimRMS.pt1",
           "pt6","parabolic fits\\z-shim.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)

   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)


#############################################################
# Import shim parameters from Standard Spinsolve software
#
# psPar is a structure containing the current UI parameters
# Returns a structure with the shim parameters updated.
#############################################################

procedure(importSpinsolveShims, psPar)

   par = setupUtilities:importSpinsolveShims(psPar)

endproc(struct(par))


#########################################################
# Load the shim values from a file in the preferences
# SpinsolveExpert shim folder
#########################################################

procedure(loadBestShims, psPar)

   par = setupUtilities:loadShims()

   if(par == null)
      return(null)
   endif

# Extract the shims value
   shimNames = ["xshim", "yshim",  "zshim",
                "z2shim", "zxshim", "zyshim", "x2y2shim",
                "xyshim", "z3shim", "z2xshim", "z2yshim",
                "zx2y2shim", "zxyshim", "x3shim", "y3shim"]

   par = getsublist(par,shimNames)
   if(psPar != null)
      par = mergelists(par,list(psPar))
      psPar = struct(sortlist(par))
   else
      psPar = struct(sortlist(getsublist(par,shimNames)))
   endif

endproc(psPar)


#############################################################
# Load a shims parameters into the GUI
#############################################################

procedure(loadCurrentShims)

   bak = getcwd()

   shimDir = "$prefdir$\\SpinsolveParameters\\Shims"
   mkdir(shimDir)
   cd(shimDir)

   file = getfilename("load","Load shim parameter file from ...","Parameter files","par")
   if(file != "cancel")
      par = load(file)

      shimNames = ["xshim", "yshim",  "zshim",
                   "z2shim", "zxshim", "zyshim", "x2y2shim",
                   "xyshim", "z3shim", "z2xshim", "z2yshim",
                   "zx2y2shim", "zxyshim", "x3shim", "y3shim"]

      par = getsublist(par,shimNames) 

      setctrlvalues(0,par)

   endif

   cd(bak)

endproc()


#############################################################
# Load the default parameters for quickshim
#############################################################

procedure(loadDefaults, exptName)

   dir = getcwd()
   cd(getmacropath())
   pref = load("$exptName$Default.par")

endproc(pref)


#########################################################
# Read the DSP parameters and return as a list
# or structure based on the mode
#########################################################

procedure(loadDSPParameters, mode="list")

   specPar = setupUtilities:loadDSPParameters(mode)

endproc(specPar)

#########################################################
# Load the shim settings from the DSP parameter list
#########################################################

procedure(loadFactoryShims, psPar)

   psPar = setupUtilities:loadFactoryShims(psPar)

endproc(psPar)

#########################################################
# Display the next saved parabolic fit
#########################################################

procedure(LoadNextFit, plt)

   fidCtrl = gPlot->getPlotObject(plt)
   text = fidCtrl->title->text()
   shimName = scanstr(text,"RMS values for '%1' shim")
   fileName = "$shimName$-shim.pt1"
   bak = getcwd()
   cd(gData->curExpt->dataPath)
   if(isdir("parabolic fits"))
      cd("parabolic fits")
      files = getfilelist(".") 
      idx = getlistindex(files,fileName)
      if(idx == size(files)-1)
         idx = 0   
      elseif(idx >= 0)
         idx = idx + 1
      endif
      fidCtrl->load(files[idx])
   endif
   cd(bak)

endproc()

#########################################################
# Display the next saved parabolic fit
#########################################################

procedure(LoadPreviousFit, plt)

   fidCtrl = gPlot->getPlotObject(plt)
   text = fidCtrl->title->text()
   shimName = scanstr(text,"RMS values for '%1' shim")
   fileName = "$shimName$-shim.pt1"
   bak = getcwd()
   cd(gData->curExpt->dataPath)
   if(isdir("parabolic fits"))
      cd("parabolic fits")
      files = getfilelist(".") 
      idx = getlistindex(files,fileName)
      if(idx == 0)
         idx = size(files)-1   
      elseif(idx > 0)
         idx = idx - 1
      endif
      fidCtrl->load(files[idx])
   endif
   cd(bak)

endproc()

#########################################################
# Collect an FID and then plot the linewidth, peak 
# and RMS
#########################################################

procedure(measureLineWidth, quick, psPar, idx)

# Set the shims and measure the linewidth
   result = TestShims:backdoor(list(psPar))

# Check for aborts
   if(wvExpStatus == "stop")
      throw("Abort pressed")
   endif
   if(wvExpStatus == "finish")
      throw("Finish pressed")
   endif

# Add the linewidth measurement to the current data
   pt3 = gView->g3->subplot(1,1)
   pt4 = gView->g4->subplot(1,1)
   pt5 = gView->g5->subplot(1,1)
   pt6 = gView->g6->subplot(1,1)
   lst = pt3->tracelist()
   if(size(lst) == 0) # First time
      sz    = 1
      x     = [0]
      y50   = [result->lw50]
      y0.55 = [result->lw0.55]
      yRMS  = [result->RMS]
   else
      (x,y50)   = pt3->trace(0)->getdata()
      (x,y0.55) = pt4->trace(0)->getdata()
      (x,yRMS)  = pt5->trace(0)->getdata()
      sz    = size(x)
      x     = join(x,[sz])
      y50   = join(y50,[result->lw50])
      y0.55 = join(y0.55,[result->lw0.55])
      yRMS  = join(yRMS,[result->RMS])
   endif

# Plot the latest 50% linewidth
   pt3->draw("false")
   pt3->plot(x,y50,"color",[128,0,0])
   pt3->axes->ymapping("linear")
   pt3->xlabel("Iteration")
   pt3->ylabel("FWHM (Hz)")
   if(result->lw50 < 1)
      pt3->title("Linewidth (50% : $result->lw50,1.2f$ Hz)")
   elseif(result->lw50 < 10)
      pt3->title("Linewidth (50% : $result->lw50,1.1f$ Hz)")
   else
      pt3->title("Linewidth (50% : $result->lw50,1.0f$ Hz)")
   endif
   pt3->grid->xgrid("on")
   pt3->grid->ygrid("on")
   pt3->grid->finexgrid("on")
   pt3->grid->fineygrid("on")
   pt3->draw("true")

# Plot the latest 0.55% linewidth
   pt4->draw("false")
   pt4->plot(x,y0.55,"color",[0,128,0])
   pt4->axes->ymapping("linear")
   pt4->xlabel("Iteration")
   pt4->ylabel("FWHM (Hz)")
   pt4->title("Linewidth (0.55% : $result->lw0.55,1.1f$ Hz)")
   pt4->grid->xgrid("on")
   pt4->grid->ygrid("on")
   pt4->grid->finexgrid("on")
   pt4->grid->fineygrid("on")
   pt4->draw("true")

# Plot the latest RMS value
   pt5->draw("false")
   pt5->plot(x,yRMS,"color",[0,0,255])
   pt5->axes->ymapping("linear")
   pt5->xlabel("Iteration")
   pt5->ylabel("FID RMS")
   pt5->title("RMS of FID")
   pt5->grid->xgrid("on")
   pt5->grid->ygrid("on")
   pt5->grid->finexgrid("on")
   pt5->grid->fineygrid("on")
   pt5->draw("true")


# Plot the current parabolic search in green
   x = quick->currentShim->values
   sz = size(x)
   y = yRMS[-sz:-1]

   pt6->draw("false")
   ct = pt6->plot(x,y)
   pt6->trace(ct)->tracetype("none")
   pt6->trace(ct)->symbolshape("square")
   pt6->trace(ct)->symbolcolor([0,128,0])
   pt6->hold("on")

# Overdraw the last point in read
   ct = pt6->plot([x[-1]],[y[-1]])
   pt6->trace(ct)->tracetype("none")
   pt6->trace(ct)->symbolshape("square")
   pt6->trace(ct)->symbolcolor([255,0,0])
  
# Plot the parabolic fit when available in blue
   if(quick->currentShim->fit != null)
      x = double([min(x):max(x)])
      A = quick->currentShim->fit[0]
      B = quick->currentShim->fit[1]
      C = quick->currentShim->fit[2]
      y2 = A*x^2 + B*x + C
      ct = pt6->plot(x,1/y2,"color",[0,0,255])
      pt6->hold("on")
   endif

   pt6->axes->ymapping("linear")
   pt6->xlabel("$quick->currentShim->name$-shim value")
   pt6->ylabel("FID RMS")
   pt6->title("RMS values for '$quick->currentShim->name$' shim")
   pt6->grid->xgrid("on")
   pt6->grid->ygrid("on")
   pt6->grid->finexgrid("on")
   pt6->grid->fineygrid("on")
   pt6->hold("off")
   pt6->draw("true")

# Save the data in pt6
   if(quick->currentShim->fit != null)
      bak = getcwd()
      cd(gData->curExpt->dataPath)
      mkdir("parabolic fits")
      cd("parabolic fits")
      pt6->save("$quick->currentShim->name$-shim.pt1")
      cd(bak)
      quick->currentShim->fit = null
   endif

# Save the linewidth history into the simplex object 
   quick->lw0.55  = y0.55
   quick->lw50    = y50

# Increment the number of steps taken
   quick->iteration = quick->iteration + 1

endproc(result)


#####################################################
# Update the enable status of the peak position
# control based on calibration checkbox
#####################################################

procedure(parameterCallBack)

   if(parentCtrl->name == "manualCalibration")
      n = findobj(0,"name","peakPositionPPM")
      :enableManualCtrl(parentCtrl->value)
      return
   endif

   if(parentCtrl->name == "shimSample")
      value = parentCtrl->text
      if(value == "reference")
         dwellTime = 200
         nrPnts = 8192 
         acqTime = 1638.4
         bandwidth = 5
         repTime = 2500
      else
         dwellTime = 300
         nrPnts = 4096 
         acqTime = 1228.8
         bandwidth = 3.3333
         repTime = 2000
      endif
      lst = mkparlist(["dwellTime","nrPnts","acqTime","bandwidth","repTime"])
      setctrlvalues(0,lst)
      return
   endif

endproc()

#############################################################
# Save the shims parameters in the GUI
#############################################################

procedure(saveCurrentShims)

   bak = getcwd()

   par = getctrlvalues(0,"list","range",[gParam->firstParameterCtrl,gParam->lastParameterCtrl])

   shimNames = ["xshim", "yshim",  "zshim",
                 "z2shim", "zxshim", "zyshim", "x2y2shim",
                 "xyshim", "z3shim", "z2xshim", "z2yshim",
                 "zx2y2shim", "zxyshim", "x3shim", "y3shim"]

   par = getsublist(par,shimNames) 

   shimDir = "$prefdir$\\SpinsolveParameters\\Shims"
   mkdir(shimDir)
   cd(shimDir)

   file = getfilename("save","Save shim parameter file as ...","Parameter files","par")
   if(file != "cancel")
      save(file,par)
   endif

   cd(bak)

endproc()

#############################################################
# Save the shim data
#############################################################

procedure(saveShimData, pt1, pt2, pt3, pt4, pt5, psPar)

   bak = getcwd()

# Save the data
   psPar->saveData = "true"
   ucsFiles:savePlot(pt1,:getPlotInfo("pt1"),list(psPar)) #,"noReport")
   ucsFiles:savePlot(pt2,:getPlotInfo("pt2"),list(psPar)) #,"noReport")
   ucsFiles:savePlot(pt3,:getPlotInfo("pt3"),list(psPar)) #,"noReport")
   ucsFiles:savePlot(pt4,:getPlotInfo("pt4"),list(psPar)) #,"noReport")
   ucsFiles:savePlot(pt5,:getPlotInfo("pt5"),list(psPar)) #,"noReport")

   cd(bak)

endproc()

#############################################################
# Save the shims parameters
#############################################################

procedure(saveShims, quick, lwInfo)

# Make a shim list from the quicks object
   sz = size(quick->shimCurrents)
   shimValues = list(sz-1)
   for(k = 1 to sz-1)
      name = quick->shimNames[k]
      value = quick->shimCurrents[k]
      shimValues[k-1] = "$name$ = $round(value)$"
   next(k)

# Add the linewidths
   shimValues = ["lw50 = $lwInfo->lw50$","lw0.55 = $lwInfo->lw0.55$"] + shimValues

# Get the SPA name
   dspPar = :loadDSPParameters("struct")
   if(dspPar == null)
      return
   endif

# Save the shims
   fileName = "$dspPar->SystemID$Shim.par"
   setupUtilities:saveShims(fileName,shimValues,lwInfo->lw50)

endproc(shimValues)

########################################################
# Update the shimCurrents in quick based on the values
# in psPar
#########################################################

procedure(updateShimCurrents,quick,psPar)

   for(k = 1 to size(quick->shimCurrents)-1)

      name = "psPar->$quick->shimNames[k]$"
      value = eval(name)
      quick->shimCurrents[k] = value 

   next(k)

endproc()

########################################################
# Update the shimCurrents in the user interface if
# text field with the correct names are present
#########################################################

procedure(updateShimsInUI, quick)

## Update the shim values used in experiment
   for(m = 1 to size(quick->shimCurrents)-1)
      name = quick->shimNames[m]
      n = findobj(0,"name",name)
      if(n > 0)
         setpar(0,n,"text",round(quick->shimCurrents[m]))
      endif
   next(m)

endproc()

#########################################################
# Update the parameter list in the UI with latest shims
# and acquisition parameters
#########################################################

procedure(updateUI, psPar)

   lst = list(psPar)
   setctrlvalues(0,lst)

endproc()
