#########################################################
# 
# TestShims
#  
# A pulse sequence suitable for performing a shim test
# by setting all the shims and then performing a pulse
# and collect experiment on hydrogen nuclei.
#
# shim - delay - pulse - delay - acq
#
# Copyright (c) Magritek Ltd 2025
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the SpinsolveExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(TestShims, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"TestShims")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("TestShims")
   else
      gExpt->addExperiment(parentPath,"TestShims",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds [""] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["nDataPnts   = nrPnts",
          "freqCh1     = b1Freq1H",
          "freqCh2     = freqCh1",
          "freqRx      = freqCh1",
          "a90Amp      = 90Amplitude1H",
          "d90Dur      = pulseLength1H",
          "dAcqDelay   = ucsUtilities:getacqDelay(d90Dur,shiftPoints,dwellTime)",
          "w1          = shimDelay*1000",
          "totPnts     = nrPnts",
          "totTime     = acqTime",
          "nx          = xshim",
          "ny          = yshim",
          "nz          = zshim",
          "nz2         = z2shim",
          "nzx         = zxshim",
          "nzy         = zyshim",
          "nx2y2       = x2y2shim",
          "nxy         = xyshim",
          "nz3         = z3shim",
          "nz2x        = z2xshim",
          "nz2y        = z2yshim",
          "nzx2y2      = zx2y2shim",
          "nzxy        = zxyshim",
          "nx3         = x3shim",
          "ny3         = y3shim",
          "spoilAmp    = 5000",
          "nxs         = xshim-(spoilAmp*xshim/(abs(xshim)+1))",
          "nys         = yshim-(spoilAmp*yshim/(abs(yshim)+1))",
          "nzs         = zshim-(spoilAmp*zshim/(abs(zshim)+1))"]
   var = [""]
   pp_list = ["nx","ny","nz","nz2","nzx","nzy","nx2y2","nxy","nz3","nz2x","nz2y","nzx2y2","nzxy","nx3","ny3","w1","a90Amp","p1","d90Dur","dAcqDelay","nDataPnts","nxs","nys","nzs"]
   pp_name = "TestShims.p"
   phase_list = [0;0]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)

#######################################################
# Run a 1Pulse experimentand return the linewidth and
# height of the highest spectral peak and the RMS value
# of the FID.
#
# psPar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
# March 2020 CDE
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)
  
# Allocate space for output data
   sumData = cmatrix(totPnts)

# Calculate suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000 # us
   fAxis = [-totPnts*zf/2:totPnts*zf/2-1]/(totTime*zf)*1000 # Hz

# Time domain filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",tAxis/1e6)
   else
      flt = matrix(totPnts)+1
   endif

# Get plot regions
   (prt,prf) = ucsPlot:getPlotReferences()
   prt->showimag("true")
   prf->showimag("false")

# First order phase correction
   guipar = guipar + ["firstOrderCorr = 0"]

# Work out frequency axis scale, label and range
# If used as a findf0 function set the ppm offset to zero
   ppmOffset = wvPPMOffset1H
   if(isvar("peakPositionPPM"))
      if(findingF0)
         ppmOffset = 0
      endif
   endif
   (fAxisDisp,fAxisLabel,fRange) = ucsPlot:generate1DFrequencyAxis(prf, fAxis, b1Freq1H, ppmOffset, 0, guipar)

# Accumulate scans
   for(scan = 0 to nrScans-1)

      wvScan = scan
      t1 = time()

    # Set phases for this scan
      (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)

    # Send all parameter values to DSP
       ucsRun:updatePPParameters(ppList,guipar,wvPort)  

    # Run the pulse program and collect the data
       ucsUtilities:suspendLock() # turn lock control loop off
      (status,data) = ucsRun:getData(totPnts,guipar)
       ucsUtilities:resumeLock()  # turn lock control loop on

    # See if stop button/escape key pressed
      if(status != "ok")
         return(0)
      endif

    # Shift the data to minimise p1
      data = shift(data,round(shiftPoints)) 

    # Correct the distortions in start of FID due to digital filter 
      data = ucsUtilities:correctFilter1(data,dwellTime)

    # Accumlate the data
      sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)

    # Process data
      (phasedTimeData,spectrum,ph0) = ucsRun:transformData(zerofill(sumData.*flt,zf*totPnts,"end"),fAxis,guipar,"fid")

    # Simple offset baseline correction
      spectrum = ucsRun:baselineCorrection(spectrum,"offset",size(spectrum)/32)

    # Plot the data 
      ucsPlot:graphTimeAndFreq(prt,prf,tAxis[1:-1],sumData[1:-1],fAxisDisp,spectrum,scan,guipar,
                               "Time data","Spectral data",
                               "Time (ms)","Amplitude (\G(m)V)",
                               fAxisLabel,"Amplitude")

   # Check timing
      check = ucsRun:checkTimeAndAbort(guipar,t1,scan,pcList,"ignoreLastScan")
      if(check == "abort")
         return(0)
      elseif(check == "finish")
         exitfor
      endif

   next(scan)

# Save the data
   ucsFiles:savePlot(prt,:getPlotInfo("pt1"),guipar,"noReport")
   ucsFiles:savePlot(prf,:getPlotInfo("pt2"),guipar,"noReport")

# Calculate linewidth of spectrum and RMS of FID
  (maxFreq,maxVal,lw50,lw0.55) = :calcLW(fAxisDisp, spectrum, guipar)

# Scale RMS by sqrt of relative acquisition time
   sc = sqrt(acqTime/41)
   RMS = rms(sumData)*sc/avg(abs(sumData[shiftPoints:10]))

# Return the linewidths, FID RMS and peak location in Hz and amplitude
   result = struct(lw50, lw0.55, RMS, maxFreq,
                   maxAmp = max(real(spectrum)))

   return(result)

endproc("execpp") # Don't remove argument

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt1","fid.pt1",
           "pt2","spectrum.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)


########################################################################
# Calculate the frequency and linewidth of the maximum peak in spectrum
########################################################################

procedure(calcLW, fAxis, spectrum, guipar)

   if(nrArgs == 3)
      assignlist(guipar)
      if(usePPMScale == "yes")
         fAxis = fAxis*single(b1Freq1H) # Convert to Hz
      endif
   endif
   fsize = size(fAxis)
   realSpectrum = real(spectrum)
   (maxVal,maxFreqIdx) = max(realSpectrum)
   (right1,right2) = findxvalue(fAxis,realSpectrum,maxFreqIdx,"right",maxVal*0.5,maxVal*0.0055)
   (left1,left2) = findxvalue(fAxis,realSpectrum,maxFreqIdx,"left",maxVal*0.5,maxVal*0.0055)
   halfwidth = right1-left1
   basewidth = right2-left2

endproc(fAxis[maxFreqIdx], maxVal, halfwidth, basewidth)


########################################################
# Load the last best shims
########################################################

procedure(loadShims)

  setupUtilities:loadShims()

endproc()

